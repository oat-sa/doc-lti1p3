{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TAO - LTI 1.3 PHP framework","text":"<p> IMS certified set of open source PHP repositories for LTI 1.3 platforms and / or tools implementations, providing:</p> <ul> <li>a set of PHP libraries for each LTI 1.3 Advantage specifications</li> <li>a Symfony bundle to ease their usage in your Symfony application</li> <li>a DevKit (using this framework) to test your LTI 1.3 integrations</li> </ul>"},{"location":"#php-libraries","title":"PHP libraries","text":"<p>PHP frameworks agnostic (only relying on PSR) LTI 1.3 libraries.</p> Library Latest version Platform Tool Documentation  Core library :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-book-reader:  Documentation  AGS library :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-book-reader:  Documentation  Basic outcome library :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-book-reader:  Documentation  Deep linking library :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-book-reader:  Documentation  NRPS library :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-book-reader:  Documentation  Proctoring library :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-book-reader:  Documentation  Submission review library :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-book-reader:  Documentation"},{"location":"#symfony-bundle","title":"Symfony bundle","text":"<p> Symfony bundle to ease the LTI 1.3 PHP libraries usage in your Symfony application.</p> Bundle Latest version Platform Tool Documentation  Symfony bundle :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-book-reader:  Documentation"},{"location":"#devkit","title":"DevKit","text":"<p>IMS certified development kit for LTI 1.3, acting as platform and / or tool.</p> DevKit Latest version Platform Tool Documentation  DevKit :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-check-circle:{ .success } :fontawesome-solid-book-reader:  Documentation"},{"location":"bundle/","title":"TAO - LTI 1.3 Symfony Bundle","text":"<p>IMS certified Symfony bundle for LTI 1.3 implementations, as platforms and / or as tools.</p> <p>This bundle automates the usage of the TAO LTI 1.3 PHP framework libraries within your Symfony application.</p>"},{"location":"bundle/#installation","title":"Installation","text":"<pre><code>$ composer require oat-sa/bundle-lti1p3\n</code></pre> <p>The associated flex recipe will generate in your application:</p> <ul> <li><code>config/routes/lti1p3.yaml</code>: configurable bundle routes (JWKS, OIDC)</li> <li><code>config/packages/lti1p3.yaml</code>: configurable bundle configuration</li> <li><code>LTI1P3_SERVICE_ENCRYPTION_KEY</code>: configurable (.env) variable (signatures security)</li> </ul>"},{"location":"bundle/#documentation","title":"Documentation","text":"<p>You can find below the bundle documentation, presented by topics.</p>"},{"location":"bundle/#quick-start","title":"Quick start","text":"<ul> <li>how to configure the bundle</li> <li>how to expose a JWKS endpoint</li> </ul>"},{"location":"bundle/#messages-interactions","title":"Messages interactions","text":"<ul> <li>how to handle LTI message interactions as a platform</li> <li>how to handle LTI message interactions as a tool</li> </ul>"},{"location":"bundle/#services-interactions","title":"Services interactions","text":"<ul> <li>how to handle LTI service interactions as a platform</li> <li>how to handle LTI service interactions as a tool</li> </ul>"},{"location":"bundle/#tests","title":"Tests","text":"<p>To run provided tests:</p> <pre><code>$ vendor/bin/phpunit\n</code></pre> <p>Note: see phpunit file for available suites.</p>"},{"location":"bundle/doc/message/platform/","title":"LTI Message - Platform","text":"<p>How to use the bundle to make your application act as a platform in the context of LTI messages.</p>"},{"location":"bundle/doc/message/platform/#generating-platform-originating-lti-messages","title":"Generating platform originating LTI messages","text":"<p>In this section, you'll see how to generate platform originating LTI messages for tools, compliant to IMS Security and OIDC specifications.</p>"},{"location":"bundle/doc/message/platform/#generic-messages","title":"Generic messages","text":"<p>You can use the provided PlatformOriginatingLaunchBuilder to build easily platform originating LTI messages.</p> <p>For example:</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Action\\Platform\\Message;\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Builder\\PlatformOriginatingLaunchBuilder;\nuse OAT\\Library\\Lti1p3Core\\Message\\LtiMessageInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\nclass MyPlatformAction\n{\n    /** @var PlatformOriginatingLaunchBuilder */\n    private $builder;\n\n    /** @var RegistrationRepositoryInterface */\n    private $repository;\n\n    public function __construct(PlatformOriginatingLaunchBuilder $builder, RegistrationRepositoryInterface $repository)\n    {\n        $this-&gt;builder = $builder;\n        $this-&gt;repository = $repository;\n    }\n\n    public function __invoke(Request $request): Response\n    {\n        $message = $this-&gt;builder-&gt;buildPlatformOriginatingLaunch(\n            $this-&gt;repository-&gt;find('local'),\n            LtiMessageInterface::LTI_MESSAGE_TYPE_RESOURCE_LINK_REQUEST,\n            'http://tool.com/launch',\n            'loginHint'\n        );\n\n        return new Response($message-&gt;toHtmlLink('launch'));\n    }\n}\n</code></pre> <p>Note: you can find more details about the <code>PlatformOriginatingLaunchBuilder</code> in the related documentation</p>"},{"location":"bundle/doc/message/platform/#lti-resource-link-launch-request-messages","title":"LTI Resource Link launch request messages","text":"<p>This bundle also allow you to perform easily launches of an LTI Resource Link.</p> <p>This becomes handy when a platform owns an LTI Resource Link to a tool resource (previously fetched with DeepLinking for example).</p> <p>First of all, you need to create or retrieve an LtiResourceLink instance:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Resource\\LtiResourceLink\\LtiResourceLink;\n\n$ltiResourceLink = new LtiResourceLink(\n    'resourceLinkIdentifier',\n    [\n        'url' =&gt; 'http://tool.com/resource',\n        'title' =&gt; 'Some title'\n    ]\n);\n</code></pre> <p>Once your <code>LtiResourceLinkInterface</code> implementation is ready, you can use the LtiResourceLinkLaunchRequestBuilder to create an LTI Resource Link launch message:</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Action\\Platform\\Message;\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Builder\\LtiResourceLinkLaunchRequestBuilder;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Resource\\LtiResourceLink\\LtiResourceLink;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\nclass MyPlatformAction\n{\n    /** @var LtiResourceLinkLaunchRequestBuilder */\n    private $builder;\n\n    /** @var RegistrationRepositoryInterface */\n    private $repository;\n\n    public function __construct(LtiResourceLinkLaunchRequestBuilder $builder, RegistrationRepositoryInterface $repository)\n    {\n        $this-&gt;builder = $builder;\n        $this-&gt;repository = $repository;\n    }\n\n    public function __invoke(Request $request): Response\n    {\n        $ltiResourceLink = new LtiResourceLink(\n            'resourceLinkIdentifier',\n            [\n                'url' =&gt; 'http://tool.com/resource',\n                'title' =&gt; 'Some title'\n            ]\n        );\n\n        $message = $this-&gt;builder-&gt;buildLtiResourceLinkLaunchRequest(\n            $ltiResourceLink,\n            $this-&gt;repository-&gt;find('local'),\n            'loginHint'\n        );\n\n        return new Response($message-&gt;toHtmlLink('launch LTI Resource Link'));\n    }\n}\n</code></pre> <p>Note: you can find more details about the <code>LtiResourceLinkLaunchRequestBuilder</code> in the related documentation</p>"},{"location":"bundle/doc/message/platform/#provide-platform-oidc-authentication","title":"Provide platform OIDC authentication","text":"<p>During the OIDC flow, the platform will be asked to provide (or delegate) authentication for a login hint.</p> <p>The OidcAuthenticationAction is automatically added to your application via the associated flex recipe, in file <code>config/routes/lti1p3.yaml</code>.</p> <p>Default route: <code>[GET,POST] /lti1p3/oidc/authentication</code></p> <p>You then just need to ensure your platform's <code>oidc_authentication_url</code> is configured accordingly:</p> <pre><code># config/packages/lti1p3.yaml\nlti1p3:\n    platforms:\n        myPlatform:\n            name: \"My Platform\"\n            audience: \"http://platform.com\"\n            oidc_authentication_url: \"http://platform.com/lti1p3/oidc/authentication\"\n            oauth2_access_token_url: \"http://platform.com/lti1p3/auth/platformKey/token\"\n</code></pre> <p>To personalise how the actual authentication will be handled, you need to provide a UserAuthenticatorInterface implementation, as explained here.</p> <p>For example:</p> <pre><code>&lt;?php\n\nnamespace App\\Security\\User;\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\User\\Result\\UserAuthenticationResult;\nuse OAT\\Library\\Lti1p3Core\\Security\\User\\Result\\UserAuthenticationResultInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\User\\UserAuthenticatorInterface;\nuse OAT\\Library\\Lti1p3Core\\User\\UserIdentity;\n\nclass UserAuthenticator implements UserAuthenticatorInterface\n{\n    public function authenticate(RegistrationInterface $registration, string $loginHint): UserAuthenticationResultInterface\n    {\n        // Perform user authentication based on the registration and login hint\n        // (ex: owned session, LDAP, external auth service, etc)\n        ...       \n\n        return new UserAuthenticationResult(\n           true,                                          // success\n           new UserIdentity('userIdentifier', 'userName') // authenticated user identity\n       ); \n    }\n}\n</code></pre> <p>You then need to activate it in your application services:</p> <pre><code># config/services.yaml\nservices:\n\n    OAT\\Library\\Lti1p3Core\\Security\\User\\UserAuthenticatorInterface:\n        class: App\\Security\\User\\UserAuthenticator\n</code></pre>"},{"location":"bundle/doc/message/platform/#validating-tool-originating-lti-messages","title":"Validating tool originating LTI messages","text":"<p>Plaforms can also receive LTI messages from tools (see DeepLinking response for example).</p> <p>This bundle offers you a way to protect your platform application endpoints that will receive tool originating messages.</p> <p>Considering you have the following platform endpoint:</p> <pre><code>#config/routes.yaml\nplatform_return:\n    path: /platform/return\n    controller: App\\Action\\Platform\\ReturnAction\n</code></pre> <p>To protect your endpoint, this bundle provides the <code>lti1p3_message_platform</code> security firewall to put in front of your routes:</p> <pre><code># config/packages/security.yaml\nsecurity:\n    firewalls:\n        secured_platform_area:\n            pattern: ^/platform/return\n            stateless: true\n            lti1p3_message_platform: true\n</code></pre> <p>You can optionally restrict allowed message types on this firewall:</p> <pre><code># config/packages/security.yaml\nsecurity:\n    firewalls:\n        secured_platform_area:\n            pattern: ^/platform/return\n            stateless: true\n            lti1p3_message_platform: { types: ['LtiDeepLinkingResponse'] }\n</code></pre> <p>It will automatically handle the provided JWT parameter validation, and add a LtiPlatformMessageSecurityToken in the security token storage, that you can use to retrieve your authentication context.</p> <p>For example:</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Action\\Platform;\n\nuse OAT\\Bundle\\Lti1p3Bundle\\Security\\Authentication\\Token\\Message\\LtiPlatformMessageSecurityToken;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Security\\Core\\Security;\n\nclass ReturnAction\n{\n    /** @var Security */\n    private $security;\n\n    public function __construct(Security $security)\n    {\n        $this-&gt;security = $security;\n    }\n\n    public function __invoke(Request $request): Response\n    {\n        /** @var LtiPlatformMessageSecurityToken $token */\n        $token = $this-&gt;security-&gt;getToken();\n\n        // Related registration\n        $registration = $token-&gt;getRegistration();\n\n        // Related LTI message payload\n        $payload = $token-&gt;getPayload();\n\n        // You can even access validation results\n        $validationResults = $token-&gt;getValidationResult();\n\n        // Your service endpoint logic ...\n\n        return new Response(...);\n    }\n}\n</code></pre>"},{"location":"bundle/doc/message/tool/","title":"LTI Message - Tool","text":"<p>How to use the bundle to make your application act as a tool in the context of LTI messages.</p>"},{"location":"bundle/doc/message/tool/#generating-tool-originating-lti-messages","title":"Generating tool originating LTI messages","text":"<p>In this section, you'll see how to generate tool originating LTI messages for platforms, compliant to IMS Security specifications.</p> <p>You can use the provided ToolOriginatingLaunchBuilder to build easily tool originating LTI messages.</p> <p>For example:</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Action\\Tool\\Message;\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Builder\\ToolOriginatingLaunchBuilder;\nuse OAT\\Library\\Lti1p3Core\\Message\\LtiMessageInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\nclass MyToolAction\n{\n    /** @var ToolOriginatingLaunchBuilder */\n    private $builder;\n\n    /** @var RegistrationRepositoryInterface */\n    private $repository;\n\n    public function __construct(ToolOriginatingLaunchBuilder $builder, RegistrationRepositoryInterface $repository)\n    {\n        $this-&gt;builder = $builder;\n        $this-&gt;repository = $repository;\n    }\n\n    public function __invoke(Request $request): Response\n    {\n        $message = $this-&gt;builder-&gt;buildToolOriginatingLaunch(\n            $this-&gt;repository-&gt;find('local'),\n            LtiMessageInterface::LTI_MESSAGE_TYPE_RESOURCE_LINK_REQUEST,\n            'http://platform.com/return'\n        );\n\n        return new Response($message-&gt;toHtmlRedirectForm()); // has to be used this way due to the expected form POST platform side\n    }\n}\n</code></pre> <p>Note: you can find more details about the <code>ToolOriginatingLaunchBuilder</code> in the related documentation</p>"},{"location":"bundle/doc/message/tool/#validating-platform-originating-lti-messages","title":"Validating platform originating LTI messages","text":"<p>In this section, you'll see how to handle platform originating messages, in compliance to IMS Security and OIDC specifications.</p>"},{"location":"bundle/doc/message/tool/#provide-tool-oidc-initiation","title":"Provide tool OIDC initiation","text":"<p>In the OIDC flow, the tool will be asked to provide a login initiation endpoint.</p> <p>The OidcInitiationAction is automatically added to your application via the associated flex recipe, in file <code>config/routes/lti1p3.yaml</code>.</p> <p>Default route: <code>[GET,POST] /lti1p3/oidc/initiation</code></p> <p>You then just need to ensure your tool's <code>oidc_initiation_url</code> is configured accordingly:</p> <p><pre><code># config/packages/lti1p3.yaml\nlti1p3:\n    tools:\n        myTool:\n            name: \"My Tool\"\n            audience: \"http://tool.com\"\n            oidc_initiation_url: \"http://tool.com/lti1p3/oidc/initiation\"\n            launch_url: \"http://tool.com/launch\"\n            deep_linking_url: ~\n</code></pre> Notes:</p> <ul> <li>it will generate a <code>state</code> as a JWT and a <code>nonce</code> that need to be returned by the platform, unaltered, after OIDC authentication</li> <li>it expects to validate them on the final launch endpoint after the OIDC flow</li> </ul>"},{"location":"bundle/doc/message/tool/#protecting-tool-launch-endpoint","title":"Protecting tool launch endpoint","text":"<p>Considering you have the following tool launch endpoint:</p> <pre><code>#config/routes.yaml\nplatform_service:\n    path: /launch\n    controller: App\\Action\\Tool\\LtiLaunchAction\n</code></pre> <p>To protect your endpoint, this bundle provides the <code>lti1p3_message_tool</code> security firewall to put in front of your routes:</p> <pre><code># config/packages/security.yaml\nsecurity:\n    firewalls:\n        secured_tool_area:\n            pattern: ^/launch\n            stateless: true\n            lti1p3_message_tool: true\n</code></pre> <p>You can optionally restrict allowed message types on this firewall:</p> <pre><code># config/packages/security.yaml\nsecurity:\n    firewalls:\n        secured_tool_area:\n            pattern: ^/launch\n            stateless: true\n            lti1p3_message_tool: { types: ['LtiResourceLinkRequest'] }\n</code></pre> <p>It will automatically handle the provided id token and state validations, and add a LtiToolMessageSecurityToken in the security token storage, that you can use to retrieve your authentication context.</p> <p>For example:</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Action\\Tool;\n\nuse OAT\\Bundle\\Lti1p3Bundle\\Security\\Authentication\\Token\\Message\\LtiToolMessageSecurityToken;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Security\\Core\\Security;\n\nclass LtiLaunchAction\n{\n    /** @var Security */\n    private $security;\n\n    public function __construct(Security $security)\n    {\n        $this-&gt;security = $security;\n    }\n\n    public function __invoke(Request $request): Response\n    {\n        /** @var LtiToolMessageSecurityToken $token */\n        $token = $this-&gt;security-&gt;getToken();\n\n        // Related registration\n        $registration = $token-&gt;getRegistration();\n\n        // Related LTI message payload\n        $payload = $token-&gt;getPayload();\n\n        // Related OIDC state\n        $state = $token-&gt;getState();\n\n        // You can even access validation results\n        $validationResults = $token-&gt;getValidationResult();\n\n        // Your service endpoint logic ...\n\n        return new Response(...);\n    }\n}\n</code></pre>"},{"location":"bundle/doc/message/tool/#customize-launch-error-handling","title":"Customize launch error handling","text":"<p>During the tool launch, errors can happen (invalid token, nonce already taken, etc).</p> <p>By default, via the LtiToolMessageExceptionHandler, the bundle detects if the launch provides a launch presentation claim, and performs automatically the redirection to the <code>return_url</code>, if given (by appending the <code>lti_errormsg</code> query parameter containing the actual error message). If no <code>return_url</code> is given, it'll bubble up the exception.</p> <p>This default behaviour can be customised if you provide your own LtiToolMessageExceptionHandlerInterface implementation.</p> <p>For example, if you need to translate:</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Security\\Exception;\n\nuse OAT\\Bundle\\Lti1p3Bundle\\Security\\Exception\\LtiToolMessageExceptionHandlerInterface;\nuse Symfony\\Component\\HttpFoundation\\RedirectResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\nuse Throwable;\n\nclass MyExceptionHandler implements LtiToolMessageExceptionHandlerInterface\n{\n    /** @var TranslatorInterface */\n    private $translator;\n\n    public function __construct(TranslatorInterface $translator)\n    {\n        $this-&gt;translator = $translator;\n    }\n\n    public function handle(Throwable $exception, Request $request): Response\n    {\n        $message = $this-&gt;translator-&gt;trans($exception-&gt;getMessage());\n\n        return new RedirectResponse(sprintf('http://platform.com/error?lti_errormsg=%s', $message));\n    }\n}\n</code></pre> <p>You then need to activate it in your application services:</p> <pre><code># config/services.yaml\nservices:\n\n    OAT\\Bundle\\Lti1p3Bundle\\Security\\Exception\\LtiToolMessageExceptionHandlerInterface:\n        class: App\\Security\\Exception\\MyExceptionHandler\n</code></pre>"},{"location":"bundle/doc/quickstart/configuration/","title":"Configuration","text":"<p>How to provide configuration to allow your application to act as LTI platform, or tool, or both.</p>"},{"location":"bundle/doc/quickstart/configuration/#overview","title":"Overview","text":"<p>On installation, the associated flex recipe creates the configuration file <code>config/packages/lti1p3.yaml</code>, containing:</p> <pre><code># config/packages/lti1p3.yaml\nlti1p3:\n    key_chains:\n        platformKey:\n            key_set_name: \"platformSet\"\n            public_key: \"file://%kernel.project_dir%/config/secrets/dev/public.key\"\n            private_key: \"file://%kernel.project_dir%/config/secrets/dev/private.key\"\n            private_key_passphrase: ~\n        toolKey:\n            key_set_name: \"toolSet\"\n            public_key: \"file://%kernel.project_dir%/config/secrets/dev/public.key\"\n            private_key: \"file://%kernel.project_dir%/config/secrets/dev/private.key\"\n            private_key_passphrase: ~\n    platforms:\n        localPlatform:\n            name: \"Local platform\"\n            audience: \"http://localhost/platform\"\n            oidc_authentication_url: \"http://localhost/lti1p3/oidc/authentication\"\n            oauth2_access_token_url: \"http://localhost/lti1p3/auth/platformKey/token\"\n    tools:\n        localTool:\n            name: \"Local tool\"\n            audience: \"http://localhost/tool\"\n            oidc_initiation_url: \"http://localhost/lti1p3/oidc/initiation\"\n            launch_url: ~\n            deep_linking_url: ~\n    registrations:\n        local:\n            client_id: \"client_id\"\n            platform: \"localPlatform\"\n            tool: \"localTool\"\n            deployment_ids:\n                - \"deploymentId1\"\n            platform_key_chain: \"platformKey\"\n            tool_key_chain: \"toolKey\"\n            platform_jwks_url: ~\n            tool_jwks_url: ~\n</code></pre> <p>In this setup, the bundle allows your application to act as a platform AND as a tool.</p> <p>It contains:</p> <ul> <li>2 key chains (<code>platformKey</code> and <code>toolKey</code>) that can be used for registration, JWKS for example</li> <li>1 platform <code>localPlatform</code> with default urls (hostname to adapt)</li> <li>1 tool <code>localTool</code> with default urls (hostname to adapt)</li> <li>1 registration <code>local</code> that deploys the <code>localTool</code> for the <code>localPlatform</code> (with client id <code>client_id</code>, deployment id <code>deploymentId1</code> and using respective <code>platformKey</code> and <code>toolKey</code> key chains to secure communications)</li> </ul>"},{"location":"bundle/doc/quickstart/configuration/#configure-a-keychain","title":"Configure a keychain","text":"<p>First you need to generate a key pair as explained here:</p> <pre><code>$ mkdir -p config/secrets/dev\n$ openssl genrsa -out config/secrets/dev/private.key 2048\n$ openssl rsa -in config/secrets/dev/private.key -outform PEM -pubout -out config/secrets/dev/public.key\n</code></pre> <p>Then, add a key chain:</p> <p><pre><code># config/packages/lti1p3.yaml\nlti1p3:\n    key_chains:\n        myKey:\n            key_set_name: \"myKeySetName\"               # [required] key set name\n            public_key: \"file://path/to/public.key\"    # [required] path / content of the public key\n            private_key: \"file://path/to/private.key\"  # [optional] path / content of the private key\n            private_key_passphrase: '...'              # [optional] private key passphrase\n            algorithm: 'RS256'                         # [optional] keys algorithm (default: RS256)\n</code></pre> Notes:</p> <ul> <li>optional keys can be omitted</li> <li>the unique identifier <code>myKey</code> can be used from the KeyChainRepositoryInterface</li> <li>the key set name <code>myKeySetName</code> can be used to group key chains together, like by example in the JwksAction</li> </ul>"},{"location":"bundle/doc/quickstart/configuration/#configure-a-platform","title":"Configure a platform","text":"<p>Platforms (owned or external) can be configured as following:</p> <p><pre><code># config/packages/lti1p3.yaml\nlti1p3:\n    platforms:\n        myPlatform:\n            name: \"My Platform\"                                                           # [required] platform name\n            audience: \"http://platform.com\"                                               # [required] platform audience\n            oidc_authentication_url: \"http://platform.com/lti1p3/oidc/authentication\"     # [optional] platform OIDC auth url\n            oauth2_access_token_url: \"http://platform.com/lti1p3/auth/platformKey/token\"  # [optional] platform access token url\n</code></pre> Notes:</p> <ul> <li>optional keys can be omitted</li> <li>the unique identifier <code>myPlatform</code> can be used into registrations creation (ex: <code>platform: \"myPlatform\"</code>)</li> <li>the <code>audience</code> will be used in JWT based communications as issuer </li> <li>the <code>oidc_authentication_url</code> is automated by the OidcAuthenticationAction</li> <li>the <code>oauth2_access_token_url</code>, automated by the OAuth2AccessTokenCreationAction, provides the key chain identifier <code>platformKey</code> as an uri param to offer an oauth2 server using this key</li> </ul>"},{"location":"bundle/doc/quickstart/configuration/#configure-a-tool","title":"Configure a tool","text":"<p>Tools (owned or external) can be configured as following:</p> <p><pre><code># config/packages/lti1p3.yaml\nlti1p3:\n    tools:\n        myTool:\n            name: \"My Tool\"                                               # [required] tool name\n            audience: \"http://tool.com\"                                   # [required] tool audience\n            oidc_initiation_url: \"http://tool.com/lti1p3/oidc/initiation\" # [required] tool OIDC init url\n            launch_url: \"http://tool.com/launch\"                          # [optional] tool default launch url\n            deep_linking_url: ~                                           # [optional] tool DeepLinking url\n</code></pre> Notes:</p> <ul> <li>optional keys can be omitted</li> <li>the unique identifier <code>myTool</code> can be used into registrations creation (ex: <code>tool: \"myTool\"</code>)</li> <li>the <code>audience</code> will be used in JWT based communications as issuer </li> <li>the <code>oidc_initiation_url</code> is handled by the OidcInitiationAction</li> <li>the <code>launch_url</code> is used to configure your default tool launch url</li> <li>the <code>deep_linking_url</code> is used to configure your default tool DeepLinking url (for content selection)</li> </ul>"},{"location":"bundle/doc/quickstart/configuration/#configure-a-registration","title":"Configure a registration","text":"<p>To add a registration:</p> <p><pre><code># config/packages/lti1p3.yaml\nlti1p3:\n    registrations:\n        myRegistration:\n            client_id: \"myClientId\"                                                            # [required] client id\n            platform: \"myPlatform\"                                                             # [required] platform identifier\n            tool: \"myTool\"                                                                     # [required] tool identifier\n            deployment_ids:                                                                    # [required] deployment ids\n                - \"myDeploymentId1\"\n                - \"myDeploymentId2\"\n            platform_key_chain: \"myPlatformKey\"                                                # [optional] platform key chain identifier\n            tool_key_chain: \"myToolKey\"                                                        # [optional] tool key chain identifier\n            platform_jwks_url: \"http://platform.com/lti1p3/.well-known/jwks/platformSet.json\"  # [optional] platform JWKS url\n            tool_jwks_url: \"http://tool.com/lti1p3/.well-known/jwks/toolSet.json\"              # [optional] tool JWKS url\n            order: 1                                                                           # [optional] order of the registration\n</code></pre> Notes:</p> <ul> <li>optional keys can be omitted</li> <li>the unique identifier <code>myRegistration</code> allows the registration to be fetched from the RegistrationRepositoryInterface</li> <li>the client id <code>myClientId</code> will be used in JWT based communications as client_id</li> <li>the defined <code>myTool</code> tool will be registered for the defined <code>myPlatform</code> platform</li> <li>the <code>myPlatformKey</code> and <code>myToolKey</code> key chains will be used to sign respectively from <code>myPlatform</code> and <code>myTool</code></li> <li>the JWKS urls are exposed by the JwksAction (if you own them)</li> <li>the <code>order</code> can be used to order registration (integer value), all non ordered registrations will go last, in declaration order</li> </ul>"},{"location":"bundle/doc/quickstart/jwks/","title":"JWKS Endpoint","text":"<p>How to use the bundle to expose a JWKS endpoint to expose security keys for your platforms and tools.</p>"},{"location":"bundle/doc/quickstart/jwks/#configure-a-jwks-endpoint","title":"Configure a JWKS endpoint","text":"<p>A JWKS endpoint may be used to expose security keys components between platforms and tools.</p> <p>The bundle provides a ready to use route handled by JwksAction, automatically added to your application routes via the associated flex recipe, in file <code>config/routes/lti1p3.yaml</code></p> <p>Default route: <code>[GET] /lti1p3/.well-known/jwks/{keySetName}.json</code></p> <p>Configuration example: <pre><code># config/packages/lti1p3.yaml\nlti1p3:\n    key_chains:\n        platformKey1:\n            key_set_name: \"platformSet\"\n            public_key: \"file://%kernel.project_dir%/config/secrets/dev/platform/public1.key\"\n            private_key: \"file://%kernel.project_dir%/config/secrets/dev/platform/private1.key\"\n            private_key_passphrase: ~\n        platformKey2:\n            key_set_name: \"platformSet\"\n            public_key: \"file://%kernel.project_dir%/config/secrets/dev/platform/public2.key\"\n            private_key: \"file://%kernel.project_dir%/config/secrets/dev/platform/private2.key\"\n            private_key_passphrase: ~\n        toolKey1:\n            key_set_name: \"toolSet\"\n            public_key: \"file://%kernel.project_dir%/config/secrets/dev/tool/public1.key\"\n            private_key: \"file://%kernel.project_dir%/config/secrets/dev/tool/private1.key\"\n            private_key_passphrase: ~\n        toolKey2:\n            key_set_name: \"toolSet\"\n            public_key: \"file://%kernel.project_dir%/config/secrets/dev/tool/public2.key\"\n            private_key: \"file://%kernel.project_dir%/config/secrets/dev/tool/private2.key\"\n            private_key_passphrase: ~\n    ...\n    platforms:\n        localPlatform:\n            name: \"Local platform\"\n            audience: \"http://localhost/platform\"\n            oidc_authentication_url: \"http://localhost/lti1p3/oidc/authentication\"\n            oauth2_access_token_url: \"http://localhost/lti1p3/auth/platformKey/token\"\n        localTool:\n            name: \"Local tool\"\n            audience: \"http://localhost/tool\"\n            oidc_initiation_url: \"http://localhost/lti1p3/oidc/initiation\"\n            launch_url: ~\n            deep_linking_url: ~\n    ...\n    registrations:\n        local:\n            client_id: \"client_id\"\n            platform: \"localPlatform\"\n            tool: \"localTool\"\n            deployment_ids:\n                - \"deploymentId1\"\n            platform_key_chain: \"platformKey\"\n            tool_key_chain: \"toolKey\"\n            platform_jwks_url: \"http://localhost/lti1p3/.well-known/jwks/platformSet.json\"\n            tool_jwks_url: \"http://localhost/lti1p3/.well-known/jwks/toolSet.json\"\n</code></pre></p> <p>Notes:</p> <ul> <li>the dynamic route <code>[GET] /lti1p3/.well-known/jwks/{keySetName}.json</code> expects a key set name, like <code>platformSet</code> or <code>toolSet</code>, to group key chains and expose their JWK as JWKS</li> <li>you can then declare in a registration involving your platform <code>localPlatform</code> that the <code>platform_jwks_url</code> will be <code>http://localhost/lti1p3/.well-known/jwks/platformSet.json</code>: it will expose the keys for the set name <code>platformSet</code></li> <li>you can then declare in a registration involving your tool <code>localTool</code> that the <code>tool_jwks_url</code> will be <code>http://localhost/lti1p3/.well-known/jwks/toolSet.json</code>: it will expose the keys for the set name <code>toolSet</code></li> </ul>"},{"location":"bundle/doc/service/platform/","title":"LTI Service - Platform","text":"<p>How to use the bundle to make your application act as a platform in the context of LTI services.</p>"},{"location":"bundle/doc/service/platform/#providing-platform-service-access-token-endpoint","title":"Providing platform service access token endpoint","text":"<p>The OAuth2AccessTokenCreationAction is automatically added to your application via the related flex recipe, in file <code>config/routes/lti1p3.yaml</code>.</p> <p>Default route: <code>[POST] '/lti1p3/auth/{keyChainIdentifier}/token'</code></p> <p>This endpoint:</p> <ul> <li>allow tools to get granted to call your platform services endpoints, by following the client_credentials grant type with assertion. </li> <li>is working for a defined <code>keyChainIdentifier</code> as explained here, so you can expose several of them if your application is acting as several deployed platforms</li> <li>is able to grant (give access tokens) for a defined list of allowed scopes </li> </ul> <p>You must first configure the list of allowed scopes to grant access tokens:</p> <pre><code># config/packages/lti1p3.yaml\nlti1p3:\n    scopes:\n        - 'https://purl.imsglobal.org/spec/lti-ags/scope/lineitem'\n        - 'https://purl.imsglobal.org/spec/lti-ags/scope/result/read'\n</code></pre> <p>Then, if you configure a key chain as following:</p> <pre><code># config/packages/lti1p3.yaml\nlti1p3:\n    key_chains:\n        platformKey:\n            key_set_name: \"platformSet\"\n            public_key: \"file://path/to/public.key\"\n            private_key: \"file://path/to/private.key\"\n            private_key_passphrase: 'someSecretPassPhrase'\n</code></pre> <p>You can then configure a platform as following (using the key chain identifier <code>platformKey</code>):</p> <pre><code># config/packages/lti1p3.yaml\nlti1p3:\n    platforms:\n        myPlatform:\n            name: \"My Platform\"\n            audience: \"http://platform.com\"\n            oidc_authentication_url: \"http://platform.com/lti1p3/oidc/authentication\"\n            oauth2_access_token_url: \"http://platform.com/lti1p3/auth/platformKey/token\"\n</code></pre> <p>Once set up, tools can request access tokens by following the client_credentials grant type with assertion:</p> <ul> <li><code>grant_type</code>: <code>client_credentials</code></li> <li><code>client_assertion_type</code>: <code>urn:ietf:params:oauth:client-assertion-type:jwt-bearer</code></li> <li><code>client_assertion</code>: the tool's generated JWT assertion</li> <li><code>scope</code>: <code>https://purl.imsglobal.org/spec/lti-ags/scope/lineitem https://purl.imsglobal.org/spec/lti-ags/scope/result/read</code></li> </ul> <p>Request example:</p> <pre><code>POST /lti1p3/auth/platformKey/token HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=client_credentials\n&amp;client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer\n&amp;client_assertion=eyJ0eXAiOi....\n&amp;scope=http%3A%2F%2Fimsglobal.org%2Fspec%2Flti-ags%2Fscope%2Flineitem%20http%3A%2F%2Fimsglobal.org%2Fspec%2Flti-ags%2Fscope%2Fresult%2Fread \n</code></pre> <p>As a response, the OAuth2AccessTokenCreationAction will offer an access token (following OAuth2 standards), valid for <code>3600 seconds</code>:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n\n{\n    \"access_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1N.....\",\n    \"token_type\" : \"bearer\",\n    \"expires_in\" : 3600,\n    \"scope\" : \"https://purl.imsglobal.org/spec/lti-ags/scope/lineitem https://purl.imsglobal.org/spec/lti-ags/scope/result/read\"    \n} \n</code></pre> <p>Notes:</p> <ul> <li>a <code>HTTP 400</code> response is returned if the requested scopes are not configured, or invalid</li> <li>a <code>HTTP 401</code> response is returned if the client assertion cannot match a registered tool</li> <li>to automate (and cache) authentication grants from the tools side, a LtiServiceClient is ready to use for your LTI service calls as explained here</li> </ul>"},{"location":"bundle/doc/service/platform/#protecting-platform-service-endpoints","title":"Protecting platform service endpoints","text":"<p>For example, considering you have the following platform service endpoints:</p> <pre><code>#config/routes.yaml\nplatform_service_ags_lineitem:\n    path: /platform/service/ags/lineitem\n    controller: App\\Action\\Platform\\Service\\Ags\\LineItemAction\nplatform_service_ags_result:\n    path: /platform/service/ags/result\n    controller: App\\Action\\Platform\\Service\\Ags\\ResultAction\n</code></pre> <p>To protect your endpoint, this bundle provides the <code>lti1p3_service</code> security firewall to put in front of your routes:</p> <pre><code># config/packages/security.yaml\nsecurity:\n    firewalls:\n        secured_service_ags_lineitem_area:\n            pattern: ^/platform/service/ags/lineitem\n            stateless: true\n            lti1p3_service: { scopes: ['https://purl.imsglobal.org/spec/lti-ags/scope/lineitem'] }\n        secured_service_ags_result_area:\n            pattern: ^/platform/service/ags/result\n            stateless: true\n            lti1p3_service: { scopes: ['https://purl.imsglobal.org/spec/lti-ags/scope/result/read'] }\n</code></pre> <p>Note: you can define per firewall the list of allowed scopes, to have better granularity for your endpoints protection.</p> <p>It will:</p> <ul> <li>handle the provided access token validation (signature validity, expiry, matching configured firewall scopes, etc ...)</li> <li>add on success a LtiServiceSecurityToken in the security token storage, that you can use to retrieve your authentication context</li> </ul> <p>For example (in one of the endpoints):</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Action\\Platform\\Service\\Ags;\n\nuse OAT\\Bundle\\Lti1p3Bundle\\Security\\Authentication\\Token\\Service\\LtiServiceSecurityToken;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Security\\Core\\Security;\n\nclass LineItemAction\n{\n    /** @var Security */\n    private $security;\n\n    public function __construct(Security $security)\n    {\n        $this-&gt;security = $security;\n    }\n\n    public function __invoke(Request $request): Response\n    {\n        /** @var LtiServiceSecurityToken $token */\n        $token = $this-&gt;security-&gt;getToken();\n\n        // Related registration (to spare queries)\n        $registration = $token-&gt;getRegistration();\n\n        // Related access token\n        $token = $token-&gt;getAccessToken();\n\n        // Related scopes (if you want to implement some ACL)\n        $scopes = $token-&gt;getScopes(); // ['https://purl.imsglobal.org/spec/lti-ags/scope/lineitem']\n\n        // You can even access validation results\n        $validationResults = $token-&gt;getValidationResult();\n\n        // Your service endpoint logic ...\n\n        return new Response(...);\n    }\n}\n</code></pre>"},{"location":"bundle/doc/service/platform/#providing-platform-service-endpoints-using-the-lti-libraries","title":"Providing platform service endpoints using the LTI libraries","text":"<p>We provide a collection of LTI libraries to offer LTI capabilities (NRPS, AGS, basic outcomes, etc) to your application.</p> <p>The bundle provides a way to easily integrate them when it comes to expose LTI services endpoints:</p> <ul> <li>the core LtiServiceServerRequestHandlerInterface is implemented by those libraries to provide their service endpoints logic</li> <li>the bundle LtiServiceServerHttpFoundationRequestHandlerInterface symfony service automates any <code>LtiServiceServerRequestHandlerInterface</code> implementation execution</li> <li>the bundle LtiServiceServerHttpFoundationRequestHandlerFactoryInterface symfony service can be used to ease the <code>LtiServiceServerHttpFoundationRequestHandlerInterface</code> creation (symfony service factory)</li> </ul> <p>For example, let's implement step by step the NRPS library membership service endpoint into your application:</p> <ul> <li>install the library</li> </ul> <pre><code>$ composer require oat-sa/lib-lti1p3-nrps\n</code></pre> <ul> <li>allow NRPS scope</li> </ul> <pre><code># config/packages/lti1p3.yaml\nlti1p3:\n    scopes:\n        - 'https://purl.imsglobal.org/spec/lti-nrps/scope/contextmembership.readonly'\n</code></pre> <ul> <li>provide a required MembershipServiceServerBuilderInterface implementation</li> </ul> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Nrps;\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationInterface;\nuse OAT\\Library\\Lti1p3Nrps\\Model\\Membership\\MembershipInterface;\nuse OAT\\Library\\Lti1p3Nrps\\Service\\Server\\Builder\\MembershipServiceServerBuilderInterface;\n\nclass MembershipServiceServerBuilder implements MembershipServiceServerBuilderInterface \n{\n    public function buildContextMembership(\n        RegistrationInterface $registration,\n        ?string $role = null,\n        ?int $limit = null,\n        ?int $offset = null\n    ): MembershipInterface {\n        // Logic for building context membership for a given registration\n    }\n\n    public function buildResourceLinkMembership(\n        RegistrationInterface $registration,\n        string $resourceLinkIdentifier,\n        ?string $role = null,\n        ?int $limit = null,\n        ?int $offset = null\n    ): MembershipInterface {\n        // Logic for building resource link membership for a given registration and resource link identifier\n    }\n};\n</code></pre> <ul> <li>register the NRPS library request handler using your builder in your application services</li> </ul> <pre><code># config/services.yaml\nservices:\n    OAT\\Library\\Lti1p3Nrps\\Service\\Server\\Handler\\MembershipServiceServerRequestHandler:\n        arguments:\n            - '@App\\Nrps\\MembershipServiceServerBuilder'\n</code></pre> <ul> <li>use the LtiServiceServerHttpFoundationRequestHandlerFactoryInterface service factory to create a controller service</li> </ul> <pre><code># config/services.yaml\nservices:\n    app.nrps_membership_controller:\n        class: OAT\\Bundle\\Lti1p3Bundle\\Service\\Server\\Handler\\LtiServiceServerHttpFoundationRequestHandler\n        factory: ['@OAT\\Bundle\\Lti1p3Bundle\\Service\\Server\\Factory\\LtiServiceServerHttpFoundationRequestHandlerFactoryInterface', 'create']\n        arguments:\n            - '@OAT\\Library\\Lti1p3Nrps\\Service\\Server\\Handler\\MembershipServiceServerRequestHandler'\n        tags: ['controller.service_arguments']\n</code></pre> <ul> <li>bind this controller service to a route in your application</li> </ul> <pre><code># config/routes.yaml\nnrps_membership:\n    path: /platform/service/nrps\n    controller: app.nrps_membership_controller\n</code></pre> <ul> <li>protect this route using the bundle service firewall</li> </ul> <pre><code># config/packages/security.yaml\nsecurity:\n    firewalls:\n        secured_service_nrps_area:\n            pattern: ^/platform/service/nrps\n            stateless: true\n            lti1p3_service: { scopes: ['https://purl.imsglobal.org/spec/lti-nrps/scope/contextmembership.readonly'] }\n</code></pre> <p>At this point, your application now offers a new endpoint <code>[GET] /platform/service/nrps</code>, that automates:</p> <ul> <li>HTTP method validation</li> <li>NRPS content type validation</li> <li>access token validation</li> <li>access token NRPS scope validation</li> <li>the response of NRPS memberships representations, relying on the provided membership builder implementation</li> </ul> <p>Note: exposing a controller as service is convenient but not mandatory, you can still inject the LtiServiceServerHttpFoundationRequestHandlerFactoryInterface in a controller constructor to have more control on this process, as done in the bundle TestServiceAction for example.</p>"},{"location":"bundle/doc/service/tool/","title":"LTI Service - Tool","text":"<p>How to use the bundle to make your application act as a tool in the context of LTI services.</p>"},{"location":"bundle/doc/service/tool/#using-the-ltiserviceclient","title":"Using the LTIServiceClient","text":"<p>In LTI services context, a tool, in order to call a service platform endpoint, need to be granted following the client_credentials grant type with assertion.</p> <p>The client LtiServiceClient is available form your application container to make authenticated LTI service calls to a platform by following this standard.</p> <p>To use it, you can inject anywhere you need the the <code>LtiServiceClientInterface</code> and you need to provide on which registered platform you want to make the call.</p> <p>For example:</p> <p><pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Action\\Tool\\Service;\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Service\\Client\\LtiServiceClientInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\nclass LtiServiceClientAction\n{\n    /** @var RegistrationRepositoryInterface */\n    private $repository;\n\n    /** @var LtiServiceClientInterface */\n    private $client;\n\n    public function __construct(RegistrationRepositoryInterface $repository, LtiServiceClientInterface $client)\n    {\n        $this-&gt;repository = $repository;\n        $this-&gt;client = $client;\n    }\n\n    public function __invoke(Request $request): Response\n    {\n        $registration = $this-&gt;repository-&gt;find(...);\n\n        $serviceResponse = $this-&gt;client-&gt;request(\n            $registration,                    // Will ask the grant on the registration platform oauth2 endpoint, or form cache\n            'GET',                            // Service call method\n            'http://platform.com/service',    // Service call url\n            ['some' =&gt; 'options'],            // Options\n            ['scope1', 'scope2']              // Scopes\n        );\n\n        // Your logic based on the $serviceResponse ...\n\n        return new Response(...);\n    }\n}\n</code></pre> Note: once the access token is fetched by the <code>LtiServiceClient</code>, it will cache it (into it's configured cache, for given TTL) to avoid asking every time the platform a new token.</p>"},{"location":"devkit/","title":"TAO - LTI 1.3 DevKit","text":"<p>IMS certified Symfony based development kit for LTI 1.3, to act as platform and / or tool.</p>"},{"location":"devkit/#try-it-live","title":"Try it live","text":"<p>To try it live, visit https://lti-public-devkit.dev.gcp-eu.taocloud.org.</p>"},{"location":"devkit/#ims","title":"IMS","text":"<p>You can find below IMS related information.</p>"},{"location":"devkit/#related-certifications","title":"Related certifications","text":"<ul> <li>LTI 1.3 advantage complete</li> <li>LTI 1.3 proctoring services</li> </ul>"},{"location":"devkit/#related-specifications","title":"Related specifications","text":"<ul> <li>IMS Security</li> <li>IMS LTI 1.3 Core</li> <li>IMS LTI 1.3 AGS</li> <li>IMS LTI 1.3 Basic Outcome</li> <li>IMS LTI 1.3 Deep Linking</li> <li>IMS LTI 1.3 NRPS</li> <li>IMS LTI 1.3 Proctoring</li> <li>IMS LTI 1.3 Submission Review</li> </ul>"},{"location":"devkit/#documentation","title":"Documentation","text":"<p>You can find below the development kit documentation, presented by topics.</p>"},{"location":"devkit/#installation-and-configuration","title":"Installation and configuration","text":"<ul> <li>how to install and configure the development kit</li> </ul>"},{"location":"devkit/#available-apis","title":"Available APIs","text":"<ul> <li>how to use the HTTP API of the development kit</li> <li>how to use the CLI of the development kit</li> </ul>"},{"location":"devkit/doc/api/","title":"HTTP API documentation","text":""},{"location":"devkit/doc/api/#http-api-security","title":"HTTP API security","text":"<p>Since this development kit can be registered with real LMS production instances, the HTTP API endpoints are protected by an API key.</p> <p>This API key is configurable on the .env file, in the <code>APP_API_KEY</code> environment variable.</p> <p>Every HTTP API endpoint request must provide this key as a token bearer via the request header <code>Authorization: Bearer &lt;token&gt;</code>.</p>"},{"location":"devkit/doc/api/#http-api-endpoints","title":"HTTP API endpoints","text":"<p>The development kit HTTP endpoints are described below (and also available on the development kit repository).</p> <p></p>"},{"location":"devkit/doc/cli/","title":"CLI documentation","text":""},{"location":"devkit/doc/cli/#commands","title":"Commands","text":"<p>You can find below the available commands offered by the development kit.</p>"},{"location":"devkit/doc/cli/#lti-13-messages-launch-generation-command","title":"LTI 1.3 messages launch generation command","text":"<p>Can be used if you need to programmatically generate a typed LTI 1.3 message launch via command line.</p> <p>Command details:</p> <ul> <li>command: <code>php bin/console devkit:create:message:launch</code></li> <li>command help: <code>php bin/console devkit:create:message:launch --help</code></li> <li>command options:</li> </ul> Name Short name Required Description --type -t yes type of LTI 1.3 message launch to generate --parameters -p yes parameters (JSON encoded) for the message launch generation --verbose -v no to output message launch details (disabled by default) <p>Common command execution example:</p> <pre><code>php bin/console devkit:create:message:launch -v -t LtiResourceLinkRequest -p '{\n  \"registration\": \"devkit\",\n  \"user\": {\n    \"id\": \"userIdentifier\"\n  },\n  \"claims\": {\n    \"a\": \"b\",\n    \"https://purl.imsglobal.org/spec/lti/claim/roles\": [\n      \"http://purl.imsglobal.org/vocab/lis/v2/membership#Learner\"\n    ]\n  }\n}'\n</code></pre> <p>Notes:</p> <ul> <li>setting up the option <code>-v</code> will not only return back the generated launch, but also the message launch details</li> <li>for the <code>user</code> parameter, you can provide this structure: <pre><code>\"user\": {\n  \"id\": \"userIdentifier\",     [optional, will generate uuidv4 if not provided]\n  \"name\": \"user name\",        [optional]\n  \"email\": \"user@mail.com\",   [optional]\n  \"locale\": \"en\"              [optional]\n}\n</code></pre></li> <li>for the <code>claims</code> parameter, you can provide any claim form the IMS specifications, for example: <pre><code>\"claims\": {\n  \"a\": \"b\",\n  \"https://purl.imsglobal.org/spec/lti/claim/roles\": [\n    \"http://purl.imsglobal.org/vocab/lis/v2/membership#Learner\"\n  ]\n}\n</code></pre></li> </ul> <p>Common command execution output example:</p> <pre><code>LTI 1.3 message launch link\n-----------------------\n\n http://devkit-lti1p3.localhost/lti1p3/oidc/initiation?iss=http%3A%2F%2Fdevkit-lti1p3.localhost%2Fplatform&amp;login_hint=%7B%22type%22%3A%22custom%22%2C%22user_id%22%3A%22userIdentifier%22%2C%22user_name%22%3Anull%2C%22user_email%22%3Anull%2C%22user_locale%22%3Anull%7D&amp;target_link_uri=http%3A%2F%2Fdevkit-lti1p3.localhost%2Ftool%2Flaunch&amp;lti_message_hint=eyJ0e...&amp;lti_deployment_id=deploymentId1&amp;client_id=client_id\n\nLTI 1.3 message launch details\n--------------------------\n\nUrl\n---\nhttp://devkit-lti1p3.localhost/lti1p3/oidc/initiation\n\nParameters\n----------\niss\nhttp://devkit-lti1p3.localhost/platform\nlogin_hint\n{\"type\":\"custom\",\"user_id\":\"userIdentifier\",\"user_name\":null,\"user_email\":null,\"user_locale\":null}\ntarget_link_uri\nhttp://devkit-lti1p3.localhost/tool/launch\nlti_message_hint\neyJ0e...\nlti_deployment_id\ndeploymentId1\nclient_id\nclient_id\n</code></pre> <p>Notes:</p> <ul> <li><code>LTI 1.3 message launch link</code>: message launch link to use to perform later on the launch</li> <li><code>LTI 1.3 message launch details</code>: message launch details, returned if <code>-v</code> is provided</li> </ul>"},{"location":"devkit/doc/cli/#ltiresourcelinkrequest-message","title":"LtiResourceLinkRequest message","text":"<p>Launch parameters (<code>--parameters</code>, JSON encoded) details:</p> Name Required Description registration yes registration identifier to use for the launch user no user details to use for the launch target_link_uri no target_link_uri to use for the launch, if not provided, will use default tool launch url deployment_id no deployment_id to use for the launch, if not provided, will use default registration deployment id claims no claims to use for the launch <p>Command execution example:</p> <pre><code>php bin/console devkit:create:message:launch -v -t LtiResourceLinkRequest -p '{\n  \"registration\": \"devkit\",\n  \"user\": {\n    \"id\": \"userIdentifier\",\n    \"name\": \"User Name\",\n    \"email\": \"user@email.com\",\n    \"locale\": \"en\"\n  },\n  \"target_link_uri\": \"http://devkit-lti1p3.localhost/tool/launch\",\n  \"deployment_id\": \"deploymentId1\",\n  \"claims\": {\n    \"a\": \"b\",\n    \"https://purl.imsglobal.org/spec/lti/claim/roles\": [\n      \"http://purl.imsglobal.org/vocab/lis/v2/membership#Learner\"\n    ]\n  }\n}'\n</code></pre>"},{"location":"devkit/doc/cli/#ltideeplinkingrequest-message","title":"LtiDeepLinkingRequest message","text":"<p>Launch parameters (<code>--parameters</code>, JSON encoded) details:</p> Name Required Description registration yes registration identifier to use for the launch deep_linking_settings no deep linking settings to use for the launch user no user details to use for the launch target_link_uri no target_link_uri to use for the launch, if not provided, will use default tool launch url deployment_id no deployment_id to use for the launch, if not provided, will use default registration deployment id claims no claims to use for the launch <p>Command execution example:</p> <pre><code>php bin/console devkit:create:message:launch -v -t LtiDeepLinkingRequest -p '{\n  \"registration\": \"devkit\",\n  \"deep_linking_settings\": {\n    \"accept_types\": [\"link\", \"file\", \"html\", \"ltiResourceLink\", \"image\"],\n    \"accept_media_types\": \"image/*,text/html\",\n    \"accept_presentation_document_targets\": [\"iframe\", \"window\", \"embed\"],\n    \"accept_multiple\": true,\n    \"auto_create\": false,\n    \"title\": \"This is the default title\",\n    \"text\": \"This is the default text\"\n  },\n  \"user\": {\n    \"id\": \"userIdentifier\",\n    \"name\": \"User Name\",\n    \"email\": \"user@email.com\",\n    \"locale\": \"en\"\n  },\n  \"target_link_uri\": \"http://devkit-lti1p3.localhost/tool/launch\",\n  \"deployment_id\": \"deploymentId1\",\n  \"claims\": {\n    \"a\": \"b\",\n    \"https://purl.imsglobal.org/spec/lti/claim/roles\": [\n      \"http://purl.imsglobal.org/vocab/lis/v2/membership#Learner\"\n    ]\n  }\n}'\n</code></pre>"},{"location":"devkit/doc/cli/#ltistartproctoring-message","title":"LtiStartProctoring message","text":"<p>Launch parameters (<code>--parameters</code>, JSON encoded) details:</p> Name Required Description registration yes registration identifier to use for the launch proctoring_start_assessment_url yes platform start assessment url proctoring_attempt_number no attempt number, default 1 user no user details to use for the launch target_link_uri no target_link_uri to use for the launch, if not provided, will use default tool launch url deployment_id no deployment_id to use for the launch, if not provided, will use default registration deployment id claims no claims to use for the launch <p>Command execution example:</p> <pre><code>php bin/console devkit:create:message:launch -v -t LtiStartProctoring -p '{\n  \"registration\": \"devkit\",\n  \"proctoring_start_assessment_url\": \"http://devkit-lti1p3.localhost/platform/message/return/proctoring\",\n  \"proctoring_attempt_number\": 1,\n  \"user\": {\n    \"id\": \"userIdentifier\",\n    \"name\": \"User Name\",\n    \"email\": \"user@email.com\",\n    \"locale\": \"en\"\n  },\n  \"target_link_uri\": \"http://devkit-lti1p3.localhost/tool/launch\",\n  \"deployment_id\": \"deploymentId1\",\n  \"claims\": {\n    \"a\": \"b\",\n    \"https://purl.imsglobal.org/spec/lti/claim/roles\": [\n      \"http://purl.imsglobal.org/vocab/lis/v2/membership#Learner\"\n    ]\n  }\n}'\n</code></pre>"},{"location":"devkit/doc/cli/#ltisubmissionreviewrequest-message","title":"LtiSubmissionReviewRequest message","text":"<p>Launch parameters (<code>--parameters</code>, JSON encoded) details:</p> Name Required Description registration yes registration identifier to use for the launch ags_line_item_url yes AGS line item url ags_scopes yes AGS scopes submission_owner no user who made the submission that is to be reviewed, if not provided, will use launch user information user no user details to use for the launch target_link_uri no target_link_uri to use for the launch, if not provided, will use default tool launch url deployment_id no deployment_id to use for the launch, if not provided, will use default registration deployment id claims no claims to use for the launch <p>Command execution example:</p> <pre><code>php bin/console devkit:create:message:launch -v -t LtiSubmissionReviewRequest -p '{\n  \"registration\": \"devkit\",\n  \"ags_line_item_url\": \"http://devkit-lti1p3.localhost/platform/service/ags/default/lineitems/default\",\n  \"ags_scopes\": [\n    \"https://purl.imsglobal.org/spec/lti-ags/scope/lineitem\",\n    \"https://purl.imsglobal.org/spec/lti-ags/scope/lineitem.readonly\",\n    \"https://purl.imsglobal.org/spec/lti-ags/scope/score\",\n    \"https://purl.imsglobal.org/spec/lti-ags/scope/result.readonly\"\n  ],\n  \"submission_owner\": {\n    \"id\": \"submissionOwnerIdentifier\",\n    \"name\": \"Submission Owner\",\n    \"email\": \"submission@owner.com\",\n    \"roles\": [\n      \"http://purl.imsglobal.org/vocab/lis/v2/membership#Learner\"\n    ]\n  },\n  \"user\": {\n    \"id\": \"userIdentifier\",\n    \"name\": \"User Name\",\n    \"email\": \"user@email.com\",\n    \"locale\": \"en\"\n  },\n  \"target_link_uri\": \"http://devkit-lti1p3.localhost/tool/launch\",\n  \"deployment_id\": \"deploymentId1\",\n  \"claims\": {\n    \"a\": \"b\",\n    \"https://purl.imsglobal.org/spec/lti/claim/roles\": [\n      \"http://purl.imsglobal.org/vocab/lis/v2/membership#Learner\"\n    ]\n  }\n}'\n</code></pre>"},{"location":"devkit/doc/installation/","title":"Installation and configuration","text":""},{"location":"devkit/doc/installation/#installation","title":"Installation","text":"<p>You need to ensure first you have the following installed:</p> <ul> <li>docker</li> <li>docker-compose</li> </ul> <p>After cloning this repository, you can build the provided docker stack: <pre><code>$ docker-compose up -d\n</code></pre></p> <p>Then, install required dependencies with composer: <pre><code>$ docker run --rm --interactive --tty \\\n  --volume $PWD:/app \\\n  composer install\n</code></pre></p> <p>For Windows users:</p> <ul> <li>you may have to do <code>--volume %cd%:/app</code> instead</li> <li>with powershell, you may have to do <code>--volume ${PWD}:/app</code> instead</li> </ul>"},{"location":"devkit/doc/installation/#usage","title":"Usage","text":""},{"location":"devkit/doc/installation/#application","title":"Application","text":"<p>After installation, the development kit is available on http://devkit-lti1p3.localhost</p>"},{"location":"devkit/doc/installation/#services","title":"Services","text":"<p>After installation, the following docker services are available:</p> Name Description devkit_lti1p3_traefik application proxy devkit_lti1p3_nginx application nginx web server devkit_lti1p3_phpfpm application php-fpm devkit_lti1p3_redis application cache devkit_lti1p3_redis_commander application cache administration <p>You can access:</p> Name URL devkit_lti1p3_nginx http://devkit-lti1p3.localhost devkit_lti1p3_traefik http://localhost:8080 devkit_lti1p3_redis_commander http://localhost:8081"},{"location":"devkit/doc/installation/#configuration","title":"Configuration","text":""},{"location":"devkit/doc/installation/#platforms-tools-and-registrations","title":"Platforms, tools and registrations","text":"<p>Since this development kit application relies on LTI 1.3 symfony bundle, you can find here instructions to configure it.</p>"},{"location":"devkit/doc/installation/#customization","title":"Customization","text":"<p>You can find in the config/devkit folder configuration files to customize the development kit:</p> <ul> <li>claims.yaml: configurable editor claims list</li> <li>deep_linking.yaml: configurable deep linking resources list</li> <li>users.yaml: configurable users list</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/","title":"TAO - LTI 1.3 AGS Library","text":"<p>IMS certified PHP library for LTI 1.3 Assignment and Grade Services implementations as platforms and / or as tools, based on LTI 1.3 Core library.</p>"},{"location":"libraries/lib-lti1p3-ags/#ims","title":"IMS","text":"<p>You can find below IMS related information.</p>"},{"location":"libraries/lib-lti1p3-ags/#related-certifications","title":"Related certifications","text":"<ul> <li>LTI 1.3 advantage complete</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/#related-specifications","title":"Related specifications","text":"<ul> <li>IMS LTI Assignment and Grade Services</li> <li>IMS LTI 1.3 Core</li> <li>IMS Security</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/#installation","title":"Installation","text":"<pre><code>$ composer require oat-sa/lib-lti1p3-ags\n</code></pre>"},{"location":"libraries/lib-lti1p3-ags/#documentation","title":"Documentation","text":"<p>You can find below the library documentation, presented by topics.</p>"},{"location":"libraries/lib-lti1p3-ags/#quick-start","title":"Quick start","text":"<ul> <li>how to configure the underlying LTI 1.3 Core library</li> <li>how to implement the AGS library interfaces</li> <li>how to check AGS scopes permissions</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/#line-item","title":"Line Item","text":"<ul> <li>how to use the AGS library for line items as a platform</li> <li>how to use the AGS library for line items as a tool</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/#result","title":"Result","text":"<ul> <li>how to use the AGS library for results as a platform</li> <li>how to use the AGS library for results as a tool</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/#score","title":"Score","text":"<ul> <li>how to use the AGS library for scores as a platform</li> <li>how to use the AGS library for scores as a tool</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/#tests","title":"Tests","text":"<p>To run tests:</p> <p><pre><code>$ vendor/bin/phpunit\n</code></pre> Note: see phpunit.xml.dist for available test suites.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/platform/","title":"AGS Platform - Line Item service server","text":"<p>How to use the line item service server handlers (with the core LtiServiceServer) to provide authenticated AGS endpoints for line item management as a platform.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/platform/#features","title":"Features","text":"<p>This library provides a set of line item service server handlers ready to be use with the core LtiServiceServer to handle line item management requests.</p> <ul> <li>they accept a PSR7 ServerRequestInterface,</li> <li>leverages the required IMS LTI 1.3 service authentication,</li> <li>and returns a PSR7 ResponseInterface containing the related line item service response</li> </ul> <p>They allow you to provide line item management service endpoints as specified in AGS openapi documentation.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/platform/#usage","title":"Usage","text":"<p>You can find below how to use each AGS service server request handlers to provide line item service endpoints.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/platform/#get-line-item-service-endpoint","title":"Get line item service endpoint","text":"<p>First, you need to provide a LineItemRepositoryInterface implementation, in charge to handle line items, as explained in the interfaces library documentation. </p> <p>Then:</p> <ul> <li>you can construct the GetLineItemServiceServerRequestHandler (constructed with your LineItemRepositoryInterface implementation)</li> <li>to finally expose it to requests using the core LtiServiceServer (constructed with the RequestAccessTokenValidator, from core library)</li> </ul> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Repository\\LineItemRepositoryInterface;\nuse OAT\\Library\\Lti1p3Ags\\Service\\LineItem\\Server\\Handler\\GetLineItemServiceServerRequestHandler;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Validator\\RequestAccessTokenValidator;\nuse OAT\\Library\\Lti1p3Core\\Service\\Server\\LtiServiceServer;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var LineItemRepositoryInterface $lineItemRepository */\n$lineItemRepository = ...\n\n$validator = new RequestAccessTokenValidator($registrationRepository);\n\n$handler = new GetLineItemServiceServerRequestHandler($lineItemRepository);\n\n$server = new LtiServiceServer($validator, $handler);\n\n// Generates an authenticated response containing the requested line item representation\n$response = $server-&gt;handle($request);\n</code></pre>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/platform/#list-line-items-service-endpoint","title":"List line items service endpoint","text":"<p>First, you need to provide a LineItemRepositoryInterface implementation, in charge to handle line items, as explained in the interfaces library documentation.</p> <p>Then:</p> <ul> <li>you can construct the ListLineItemsServiceServerRequestHandler (constructed with your LineItemRepositoryInterface implementation)</li> <li>to finally expose it to requests using the core LtiServiceServer (constructed with the RequestAccessTokenValidator, from core library)</li> </ul> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Repository\\LineItemRepositoryInterface;\nuse OAT\\Library\\Lti1p3Ags\\Service\\LineItem\\Server\\Handler\\ListLineItemsServiceServerRequestHandler;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Validator\\RequestAccessTokenValidator;\nuse OAT\\Library\\Lti1p3Core\\Service\\Server\\LtiServiceServer;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var LineItemRepositoryInterface $lineItemRepository */\n$lineItemRepository = ...\n\n$validator = new RequestAccessTokenValidator($registrationRepository);\n\n$handler = new ListLineItemsServiceServerRequestHandler($lineItemRepository);\n\n$server = new LtiServiceServer($validator, $handler);\n\n// Generates an authenticated response containing the requested line item list representation\n$response = $server-&gt;handle($request);\n</code></pre>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/platform/#create-line-item-service-endpoint","title":"Create line item service endpoint","text":"<p>First, you need to provide a LineItemRepositoryInterface implementation, in charge to handle line items, as explained in the interfaces library documentation.</p> <p>Then:</p> <ul> <li>you can construct the CreateLineItemServiceServerRequestHandler (constructed with your LineItemRepositoryInterface implementation)</li> <li>to finally expose it to requests using the core LtiServiceServer (constructed with the RequestAccessTokenValidator, from core library)</li> </ul> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Repository\\LineItemRepositoryInterface;\nuse OAT\\Library\\Lti1p3Ags\\Service\\LineItem\\Server\\Handler\\CreateLineItemServiceServerRequestHandler;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Validator\\RequestAccessTokenValidator;\nuse OAT\\Library\\Lti1p3Core\\Service\\Server\\LtiServiceServer;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var LineItemRepositoryInterface $lineItemRepository */\n$lineItemRepository = ...\n\n$validator = new RequestAccessTokenValidator($registrationRepository);\n\n$handler = new CreateLineItemServiceServerRequestHandler($lineItemRepository);\n\n$server = new LtiServiceServer($validator, $handler);\n\n// Generates an authenticated response containing the line item creation response\n$response = $server-&gt;handle($request);\n</code></pre>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/platform/#update-line-item-service-endpoint","title":"Update line item service endpoint","text":"<p>First, you need to provide a LineItemRepositoryInterface implementation, in charge to handle line items, as explained in the interfaces library documentation.</p> <p>Then:</p> <ul> <li>you can construct the UpdateLineItemServiceServerRequestHandler (constructed with your LineItemRepositoryInterface implementation)</li> <li>to finally expose it to requests using the core LtiServiceServer (constructed with the RequestAccessTokenValidator, from core library)</li> </ul> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Repository\\LineItemRepositoryInterface;\nuse OAT\\Library\\Lti1p3Ags\\Service\\LineItem\\Server\\Handler\\UpdateLineItemServiceServerRequestHandler;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Validator\\RequestAccessTokenValidator;\nuse OAT\\Library\\Lti1p3Core\\Service\\Server\\LtiServiceServer;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var LineItemRepositoryInterface $lineItemRepository */\n$lineItemRepository = ...\n\n$validator = new RequestAccessTokenValidator($registrationRepository);\n\n$handler = new UpdateLineItemServiceServerRequestHandler($lineItemRepository);\n\n$server = new LtiServiceServer($validator, $handler);\n\n// Generates an authenticated response containing the line item update response\n$response = $server-&gt;handle($request);\n</code></pre>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/platform/#delete-line-item-service-endpoint","title":"Delete line item service endpoint","text":"<p>First, you need to provide a LineItemRepositoryInterface implementation, in charge to handle line items, as explained in the interfaces library documentation.</p> <p>Then:</p> <ul> <li>you can construct the DeleteLineItemServiceServerRequestHandler (constructed with your LineItemRepositoryInterface implementation)</li> <li>to finally expose it to requests using the core LtiServiceServer (constructed with the RequestAccessTokenValidator, from core library)</li> </ul> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Repository\\LineItemRepositoryInterface;\nuse OAT\\Library\\Lti1p3Ags\\Service\\LineItem\\Server\\Handler\\DeleteLineItemServiceServerRequestHandler;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Validator\\RequestAccessTokenValidator;\nuse OAT\\Library\\Lti1p3Core\\Service\\Server\\LtiServiceServer;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var LineItemRepositoryInterface $lineItemRepository */\n$lineItemRepository = ...\n\n$validator = new RequestAccessTokenValidator($registrationRepository);\n\n$handler = new DeleteLineItemServiceServerRequestHandler($lineItemRepository);\n\n$server = new LtiServiceServer($validator, $handler);\n\n// Generates an authenticated response containing the line item deletion response\n$response = $server-&gt;handle($request);\n</code></pre>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/tool/","title":"AGS Tool - Line Item service client","text":"<p>How to use the LineItemServiceClient to perform authenticated AGS line item service calls as a tool.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/tool/#features","title":"Features","text":"<p>This library provides a LineItemServiceClient (based on the core LtiServiceClient) that allow line items management as a tool on AGS service endpoints exposed by a platform.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/tool/#usage","title":"Usage","text":"<p>You can find below how to use the LineItemServiceClient methods to manage line items.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/tool/#get-a-line-item","title":"Get a line item","text":"<p>To get a line item:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Service\\LineItem\\Client\\LineItemServiceClient;\nuse OAT\\Library\\Lti1p3Ags\\Service\\LineItem\\LineItemServiceInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n// Related registration\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n$lineItemClient = new LineItemServiceClient();\n\n$lineItem = $lineItemClient-&gt;getLineItem(\n    $registration,                                             // [required] as the tool, it will call the platform of this registration\n    'https://example.com/ags/contexts/1/lineitems/1',          // [required] AGS line item url\n    [LineItemServiceInterface::AUTHORIZATION_SCOPE_LINE_ITEM]  // [optional] scopes to use (default both read only and regular line item scopes)\n);\n\n// Line item identifier\necho $lineItem-&gt;getIdentifier();\n\n// Line item max score\necho $lineItem-&gt;getScoreMaximum();\n</code></pre> <p>Notes:</p> <ul> <li>you can use the method <code>getLineItemForClaim()</code> to work directly with an AGS claim received at launch</li> <li>you can use the method <code>getLineItemForPayload()</code> to work directly with an LTI message payload received at launch</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/tool/#list-line-items","title":"List line items","text":"<p>To list line items:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Service\\LineItem\\Client\\LineItemServiceClient;\nuse OAT\\Library\\Lti1p3Ags\\Service\\LineItem\\LineItemServiceInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n// Related registration\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n$lineItemClient = new LineItemServiceClient();\n\n$lineItemContainer = $lineItemClient-&gt;listLineItems(\n    $registration,                                             // [required] as the tool, it will call the platform of this registration\n    'https://example.com/ags/contexts/1/lineitems',            // [required] AGS line item container url\n    'resource_id',                                             // [optional] line item resource identifier filter (default none)\n    'resource_link_id',                                        // [optional] line item resource link identifier filter (default none)\n    'tag',                                                     // [optional] line item tag filter (default none)\n    1,                                                         // [optional] pagination limit to return (default none)\n    1,                                                         // [optional] pagination offset (default none)\n    [LineItemServiceInterface::AUTHORIZATION_SCOPE_LINE_ITEM]  // [optional] scopes to use (default both read only and regular line item scopes)\n);\n\n// Iterate on returned line items\nforeach ($lineItemContainer-&gt;getLineItems() as $lineItem) {\n    echo $lineItem-&gt;getIdentifier();\n}\n\n// Line item container relation link (to know presence of next or not)\necho $lineItemContainer-&gt;getRelationLinkUrl();\n\nif ($lineItemContainer-&gt;hasNext()) {\n    // Handle retrieval of the next line items\n}\n...\n</code></pre> <p>Notes:</p> <ul> <li>you can use the method <code>listLineItemsForClaim()</code> to work directly with an AGS claim received at launch</li> <li>you can use the method <code>listLineItemsForPayload()</code> to work directly with an LTI message payload received at launch</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/tool/#create-a-line-item","title":"Create a line item","text":"<p>To create a line item:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Model\\LineItem\\LineItem;\nuse OAT\\Library\\Lti1p3Ags\\Service\\LineItem\\Client\\LineItemServiceClient;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n// Related registration\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n$lineItemClient = new LineItemServiceClient();\n\n$lineItem = new LineItem(...);\n\n$createdLineItem = $lineItemClient-&gt;createLineItem(\n    $registration,                                             // [required] as the tool, it will call the platform of this registration\n    $lineItem,                                                 // [required] AGS line item to create\n    'https://example.com/ags/contexts/1/lineitems'             // [required] AGS line item container url\n);\n\n// Created line item identifier (given by the platform)\necho $createdLineItem-&gt;getIdentifier();\n</code></pre> <p>Notes:</p> <ul> <li>you can use the method <code>createLineItemForClaim()</code> to work directly with an AGS claim received at launch</li> <li>you can use the method <code>createLineItemForPayload()</code> to work directly with an LTI message payload received at launch</li> <li>you can also use the LineItemFactory to help your line item creation</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/tool/#update-a-line-item","title":"Update a line item","text":"<p>To update a line item:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Service\\LineItem\\Client\\LineItemServiceClient;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n// Related registration\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n$lineItemClient = new LineItemServiceClient();\n\n$lineItem = $lineItemClient-&gt;getLineItem(...);\n\n$lineItem-&gt;setScoreMaximum(100);\n\n$updatedLineItem = $lineItemClient-&gt;updateLineItem(\n    $registration,                                             // [required] as the tool, it will call the platform of this registration\n    $lineItem                                                  // [required] AGS line item to update\n);\n\n// Updated line item max score (given by the platform)\necho $updatedLineItem-&gt;getScoreMaximum();\n</code></pre> <p>Notes:</p> <ul> <li>you can use the method <code>updateLineItemForClaim()</code> to work directly with an AGS claim received at launch</li> <li>you can use the method <code>updateLineItemForPayload()</code> to work directly with an LTI message payload received at launch</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/doc/lineitem/tool/#delete-a-line-item","title":"Delete a line item","text":"<p>To delete a line item:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Service\\LineItem\\Client\\LineItemServiceClient;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n// Related registration\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n$lineItemClient = new LineItemServiceClient();\n\n$isDeleted = $lineItemClient-&gt;deleteLineItem(\n    $registration,                                             // [required] as the tool, it will call the platform of this registration\n    'https://example.com/ags/contexts/1/lineitems/1'           // [required] AGS line item url\n);\n\n// Check line item deletion success\nif ($isDeleted) {\n    // Deletion success\n}\n</code></pre> <p>Notes:</p> <ul> <li>you can use the method <code>deleteLineItemForClaim()</code> to work directly with an AGS claim received at launch</li> <li>you can use the method <code>deleteLineItemForPayload()</code> to work directly with an LTI message payload received at launch</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/doc/quickstart/interfaces/","title":"AGS library interfaces","text":"<p>Depending on the AGS services you want to provide as a platform, you have to provide your own implementations of the following interfaces.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/quickstart/interfaces/#line-item-repository-interface","title":"Line item repository interface","text":"<p>Required by:</p> <ul> <li>line item service</li> <li>score service</li> <li>result service</li> </ul> <p>In order to manage your line items, you need to provide an implementation of the LineItemRepositoryInterface.</p> <p>For example:</p> <p><pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Model\\LineItem\\LineItemInterface;\nuse OAT\\Library\\Lti1p3Ags\\Model\\LineItem\\LineItemCollectionInterface;\nuse OAT\\Library\\Lti1p3Ags\\Repository\\LineItemRepositoryInterface;\n\n$lineItemRepository = new class implements LineItemRepositoryInterface\n{\n    public function find(string $lineItemIdentifier): ?LineItemInterface\n    {\n        // TODO: Implement find() method.\n    }\n\n    public function findCollection(\n        ?string $resourceIdentifier = null,\n        ?string $resourceLinkIdentifier = null,\n        ?string $tag = null,\n        ?int $limit = null,\n        ?int $offset = null\n    ): LineItemCollectionInterface {\n        // TODO: Implement findCollection() method.\n    }\n\n    public function save(LineItemInterface $lineItem): LineItemInterface\n    {\n        // TODO: Implement save() method.\n    }\n\n    public function delete(string $lineItemIdentifier): void\n    {\n        // TODO: Implement delete() method.\n    }\n};\n</code></pre> Notes: </p> <ul> <li>the <code>save()</code> method will be called by the LTI service handlers for both line items creation and update, up to you to handle line items identifier generation the way you want in case of creation</li> <li>a simple implementation example can be found in the library tests</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/doc/quickstart/interfaces/#score-repository-interface","title":"Score repository interface","text":"<p>Required by:</p> <ul> <li>score service</li> </ul> <p>In order to manage your scores, you need to provide an implementation of the ScoreRepositoryInterface.</p> <p>For example:</p> <p><pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Model\\Score\\ScoreInterface;\nuse OAT\\Library\\Lti1p3Ags\\Repository\\ScoreRepositoryInterface;\n\n$scoreRepository = new class implements ScoreRepositoryInterface\n{\n    public function save(ScoreInterface $score): ScoreInterface\n    {\n        // TODO: Implement save() method.\n    }\n};\n</code></pre> Notes:</p> <ul> <li>the interface does not provide methods to find scores, up to you to add dedicated methods in your repository implementation to handle this the way you want</li> <li>a simple implementation example can be found in the library tests</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/doc/quickstart/interfaces/#result-repository-interface","title":"Result repository interface","text":"<p>Required by:</p> <ul> <li>result service</li> </ul> <p>In order to be able to manage your results, you need to provide an implementation of the ResultRepositoryInterface.</p> <p>For example:</p> <p><pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Model\\Result\\ResultInterface;\nuse OAT\\Library\\Lti1p3Ags\\Model\\Result\\ResultCollectionInterface;\nuse OAT\\Library\\Lti1p3Ags\\Repository\\ResultRepositoryInterface;\n\n$resultRepository = new class implements ResultRepositoryInterface\n{\n    public function findCollectionByLineItemIdentifier(\n        string $lineItemIdentifier,\n        ?int $limit = null,\n        ?int $offset = null\n    ): ResultCollectionInterface {\n        // TODO: Implement findCollectionByLineItemIdentifier() method.\n    }\n\n    public function findByLineItemIdentifierAndUserIdentifier(\n        string $lineItemIdentifier,\n        string $userIdentifier\n    ): ?ResultInterface {\n        // TODO: Implement findByLineItemIdentifierAndUserIdentifier() method.\n    }\n};\n</code></pre> Notes:</p> <ul> <li>the interface does not provide methods to persist results, p to you to add dedicated methods in your repository implementation to handle this the way you want</li> <li>as per AGS specifications  , the <code>findByLineItemIdentifierAndUserIdentifier()</code> method must return the most relevant result for a given line item and  user</li> <li>a simple implementation example can be found in the library tests</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/doc/quickstart/voter/","title":"AGS scopes permissions voter","text":"<p>How to use the ScopePermissionVoter to check what is allowed to do as a tool from the AGS claim given by the platform at LTI launch time.</p> <p>During an LTI launch, the platform may provide an AGS claim containing the list of allowed scopes:</p> <pre><code>\"https://purl.imsglobal.org/spec/lti-ags/claim/endpoint\": {\n  \"scope\": [\n    \"https://purl.imsglobal.org/spec/lti-ags/scope/lineitem.readonly\",\n    \"https://purl.imsglobal.org/spec/lti-ags/scope/result.readonly\",\n    \"https://purl.imsglobal.org/spec/lti-ags/scope/score\"\n  ],\n  \"lineitems\": \"https://www.myuniv.example.com/2344/lineitems/\",\n  \"lineitem\": \"https://www.myuniv.example.com/2344/lineitems/1234/lineitem\"\n}\n</code></pre> <p>You can use the ScopePermissionVoter to easily check what is allowed by the platform:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Voter\\ScopePermissionVoter;\n\n$agsClaimScopes = [\n    \"https://purl.imsglobal.org/spec/lti-ags/scope/lineitem.readonly\",\n    \"https://purl.imsglobal.org/spec/lti-ags/scope/result.readonly\",\n];\n\nvar_dump(ScopePermissionVoter::canReadLineItem($agsClaimScopes));  // true\nvar_dump(ScopePermissionVoter::canWriteLineItem($agsClaimScopes)); // false\nvar_dump(ScopePermissionVoter::canReadResult($agsClaimScopes));    // true\nvar_dump(ScopePermissionVoter::canWriteScore($agsClaimScopes));    // false\n\n// You can also get all permissions at once\nvar_dump(ScopePermissionVoter::getPermissions($agsClaimScopes));\n</code></pre>"},{"location":"libraries/lib-lti1p3-ags/doc/result/platform/","title":"AGS Platform - Result service server","text":"<p>How to use the ResultServiceServerRequestHandler (with the core LtiServiceServer) to provide authenticated AGS endpoint for results retrieval as a platform.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/result/platform/#features","title":"Features","text":"<p>This library provides a ResultServiceServerRequestHandler ready to be use with the core LtiServiceServer to expose results to tools, as a platform.</p> <ul> <li>it accepts a PSR7 ServerRequestInterface,</li> <li>leverages the required IMS LTI 1.3 service authentication,</li> <li>and returns a PSR7 ResponseInterface containing the result list representation.</li> </ul> <p>It allows you to provide a result service endpoint as specified in AGS openapi documentation.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/result/platform/#usage","title":"Usage","text":"<p>First, you need to provide:</p> <ul> <li>a LineItemRepositoryInterface implementation, in charge to handle line items, as explained in the interfaces library documentation</li> <li>a ResultRepositoryInterface implementation, in charge to handle results, as explained in the interfaces library documentation</li> </ul> <p>Then:</p> <ul> <li>you can construct the ResultServiceServerRequestHandler (constructed with your LineItemRepositoryInterface and ResultRepositoryInterface implementations)</li> <li>to finally expose it to requests using the core LtiServiceServer (constructed with the RequestAccessTokenValidator, from core library)</li> </ul> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Repository\\LineItemRepositoryInterface;\nuse OAT\\Library\\Lti1p3Ags\\Repository\\ResultRepositoryInterface;\nuse OAT\\Library\\Lti1p3Ags\\Service\\Result\\Server\\Handler\\ResultServiceServerRequestHandler;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Validator\\RequestAccessTokenValidator;\nuse OAT\\Library\\Lti1p3Core\\Service\\Server\\LtiServiceServer;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var LineItemRepositoryInterface $lineItemRepository */\n$lineItemRepository = ...\n\n/** @var ResultRepositoryInterface $scoreRepository */\n$resultRepository = ...\n\n$validator = new RequestAccessTokenValidator($registrationRepository);\n\n$handler = new ResultServiceServerRequestHandler($lineItemRepository, $resultRepository);\n\n$server = new LtiServiceServer($validator, $handler);\n\n// Generates an authenticated response containing the result list representation\n$response = $server-&gt;handle($request);\n</code></pre>"},{"location":"libraries/lib-lti1p3-ags/doc/result/tool/","title":"AGS Tool - Result service client","text":"<p>How to use the ResultServiceClient to perform authenticated AGS results retrieval as a tool.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/result/tool/#features","title":"Features","text":"<p>This library provides a ResultServiceClient  (based on the core LtiServiceClient) that allow results retrieval as a tool.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/result/tool/#usage","title":"Usage","text":"<p>To list results:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Service\\Result\\Client\\ResultServiceClient;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n// Related registration\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n$resultClient = new ResultServiceClient();\n\n$resultContainer = $resultClient-&gt;listResults(\n    $registration,                                      // [required] as the tool, it will call the platform of this registration\n    'https://example.com/ags/contexts/1/lineitems/1',   // [required] AGS line item url to list the results from\n    'user_id',                                          // [optional] user identifier (default none)\n    1,                                                  // [optional] pagination limit to return (default none)\n    1                                                   // [optional] pagination offset (default none)\n);\n\n// Iterate on returned results\nforeach ($resultContainer-&gt;getResults() as $result) {\n    echo $result-&gt;getResultScore();\n}\n\n// Results container relation link (to know presence of next or not)\necho $resultContainer-&gt;getRelationLinkUrl();\n\nif ($resultContainer-&gt;hasNext()) {\n    // Handle retrieval of the next results\n}\n</code></pre> <p>Notes:</p> <ul> <li>you can use the method <code>listResultsForClaim()</code> to work directly with an AGS claim received at launch</li> <li>you can use the method <code>listResultsForPayload()</code> to work directly with an LTI message payload received at launch</li> </ul>"},{"location":"libraries/lib-lti1p3-ags/doc/score/platform/","title":"AGS Platform - Score service server","text":"<p>How to use the ScoreServiceServerRequestHandler (with the core LtiServiceServer) to provide authenticated AGS endpoint for score publications as a platform.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/score/platform/#features","title":"Features","text":"<p>This library provides a ScoreServiceServerRequestHandler ready to be use with the core LtiServiceServer to accept scores publications as a platform.</p> <ul> <li>it accepts a PSR7 ServerRequestInterface,</li> <li>leverages the required IMS LTI 1.3 service authentication,</li> <li>and returns a PSR7 ResponseInterface containing the score publication response</li> </ul> <p>It allows you to provide a score service endpoint as specified in AGS openapi documentation.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/score/platform/#usage","title":"Usage","text":"<p>First, you need to provide:</p> <ul> <li>a LineItemRepositoryInterface implementation, in charge to handle line items, as explained in the interfaces library documentation</li> <li>a ScoreRepositoryInterface implementation, in charge to handle scores, as explained in the interfaces library documentation</li> </ul> <p>Then:</p> <ul> <li>you can construct the ScoreServiceServerRequestHandler (constructed with your LineItemRepositoryInterface and ScoreRepositoryInterface implementations)</li> <li>to finally expose it to requests using the core LtiServiceServer (constructed with the RequestAccessTokenValidator, from core library)</li> </ul> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Repository\\LineItemRepositoryInterface;\nuse OAT\\Library\\Lti1p3Ags\\Repository\\ScoreRepositoryInterface;\nuse OAT\\Library\\Lti1p3Ags\\Service\\Score\\Server\\Handler\\ScoreServiceServerRequestHandler;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Validator\\RequestAccessTokenValidator;\nuse OAT\\Library\\Lti1p3Core\\Service\\Server\\LtiServiceServer;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var LineItemRepositoryInterface $lineItemRepository */\n$lineItemRepository = ...\n\n/** @var ScoreRepositoryInterface $scoreRepository */\n$scoreRepository = ...\n\n$validator = new RequestAccessTokenValidator($registrationRepository);\n\n$handler = new ScoreServiceServerRequestHandler($lineItemRepository, $scoreRepository);\n\n$server = new LtiServiceServer($validator, $handler);\n\n// Generates an authenticated response containing the score publication result\n$response = $server-&gt;handle($request);\n</code></pre>"},{"location":"libraries/lib-lti1p3-ags/doc/score/tool/","title":"AGS Tool - Score service client","text":"<p>How to use the ScoreServiceClient to perform authenticated AGS scores publications as a tool.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/score/tool/#features","title":"Features","text":"<p>This library provides a ScoreServiceClient (based on the core LtiServiceClient) that allow scores publications as a tool.</p>"},{"location":"libraries/lib-lti1p3-ags/doc/score/tool/#usage","title":"Usage","text":"<p>To publish a score:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Ags\\Model\\Score\\Score;\nuse OAT\\Library\\Lti1p3Ags\\Service\\Score\\Client\\ScoreServiceClient;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n// Related registration\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n$scoreClient = new ScoreServiceClient();\n\n$score = new Score(...);\n\n$isPublished = $scoreClient-&gt;publishScore(\n    $registration,                                      // [required] as the tool, it will call the platform of this registration\n    $score,                                             // [required] AGS score to publish\n    'https://example.com/ags/contexts/1/lineitems/1'    // [required] AGS line item url to publish the score to\n);\n\n// Check score publication success\nif ($isPublished) {\n    // Publication success\n}\n</code></pre> <p>Notes:</p> <ul> <li>you can use the method <code>publishScoreForClaim()</code> to work directly with an AGS claim received at launch</li> <li>you can use the method <code>publishScoreForPayload()</code> to work directly with an LTI message payload received at launch</li> <li>you can use the ScoreFactory to ease your score creation</li> </ul>"},{"location":"libraries/lib-lti1p3-basic-outcome/","title":"TAO - LTI 1.3 Basic Outcome Library","text":"<p>PHP library for LTI 1.3 Basic Outcome implementations as platforms and / or as tools, based on LTI 1.3 Core library.</p>"},{"location":"libraries/lib-lti1p3-basic-outcome/#ims","title":"IMS","text":"<p>You can find below IMS related information.</p>"},{"location":"libraries/lib-lti1p3-basic-outcome/#related-specifications","title":"Related specifications","text":"<ul> <li>IMS LTI 1.3 Basic Outcome Service</li> <li>IMS LTI 1.3 Core</li> <li>IMS Security</li> </ul>"},{"location":"libraries/lib-lti1p3-basic-outcome/#installation","title":"Installation","text":"<pre><code>$ composer require oat-sa/lib-lti1p3-basic-outcome\n</code></pre>"},{"location":"libraries/lib-lti1p3-basic-outcome/#documentation","title":"Documentation","text":"<p>You can find below the library documentation, presented by topics.</p>"},{"location":"libraries/lib-lti1p3-basic-outcome/#configuration","title":"Configuration","text":"<ul> <li>how to configure the underlying LTI 1.3 Core library</li> </ul>"},{"location":"libraries/lib-lti1p3-basic-outcome/#platform","title":"Platform","text":"<ul> <li>how to use the basic outcome library as a platform</li> </ul>"},{"location":"libraries/lib-lti1p3-basic-outcome/#tool","title":"Tool","text":"<ul> <li>how to use the basic outcome library as a tool</li> </ul>"},{"location":"libraries/lib-lti1p3-basic-outcome/#tests","title":"Tests","text":"<p>To run tests:</p> <p><pre><code>$ vendor/bin/phpunit\n</code></pre> Note: see phpunit.xml.dist for available test suites.</p>"},{"location":"libraries/lib-lti1p3-basic-outcome/doc/platform/","title":"Basic Outcome Platform - Basic Outcome Service Server","text":"<p>How to use the BasicOutcomeServiceServerRequestHandler (with the core LtiServiceServer) to serve authenticated Basic Outcome service endpoints as a platform.</p>"},{"location":"libraries/lib-lti1p3-basic-outcome/doc/platform/#features","title":"Features","text":"<p>This library provides a BasicOutcomeServiceServerRequestHandler ready to be use with the core LtiServiceServer to handle basic outcome operations.</p> <ul> <li>it accepts a PSR7 ServerRequestInterface containing the basic outcome request,</li> <li>leverages the required IMS LTI 1.3 service authentication,</li> <li>and returns a PSR7 ResponseInterface containing the basic outcome response</li> </ul>"},{"location":"libraries/lib-lti1p3-basic-outcome/doc/platform/#usage","title":"Usage","text":"<p>First, you need to provide a BasicOutcomeServiceServerProcessorInterface implementation, in charge to process the basic outcome operations.</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3BasicOutcome\\Service\\Server\\Processor\\BasicOutcomeServiceServerProcessorInterface;\nuse OAT\\Library\\Lti1p3BasicOutcome\\Service\\Server\\Processor\\Result\\BasicOutcomeServiceServerProcessorResult;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationInterface;\n\n/** @var BasicOutcomeServiceServerProcessorInterface $processor */\n$processor = new class() implements BasicOutcomeServiceServerProcessorInterface \n{\n    public function processReadResult(\n        RegistrationInterface $registration,\n        string $sourcedId\n    ) : BasicOutcomeServiceServerProcessorResult {\n        // @todo: Logic for readResult basic outcome operations\n    }\n\n    public function processReplaceResult(\n        RegistrationInterface $registration,\n        string $sourcedId,\n        float $score,\n        string $language = 'en'\n    ) : BasicOutcomeServiceServerProcessorResult {\n        // @todo: Logic for replaceResult basic outcome operations\n    }\n\n    public function processDeleteResult(\n        RegistrationInterface $registration,\n        string $sourcedId\n    ) : BasicOutcomeServiceServerProcessorResult {\n        // @todo: Logic for deleteResult basic outcome operations\n    }\n};\n</code></pre> <p>Then:</p> <ul> <li>you can construct the BasicOutcomeServiceServerRequestHandler (constructed with your BasicOutcomeServiceServerProcessorInterface implementation)</li> <li>to finally expose it to requests using the core LtiServiceServer (constructed with the RequestAccessTokenValidator, from core library)</li> </ul> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3BasicOutcome\\Service\\Server\\Handler\\BasicOutcomeServiceServerRequestHandler;\nuse OAT\\Library\\Lti1p3BasicOutcome\\Service\\Server\\Processor\\BasicOutcomeServiceServerProcessorInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Validator\\RequestAccessTokenValidator;\nuse OAT\\Library\\Lti1p3Core\\Service\\Server\\LtiServiceServer;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n/** @var RegistrationRepositoryInterface $repository */\n$repository = ...\n\n/** @var BasicOutcomeServiceServerProcessorInterface $processor */\n$processor = ...\n\n$validator = new RequestAccessTokenValidator($repository);\n\n$handler = new BasicOutcomeServiceServerRequestHandler($processor);\n\n$server = new LtiServiceServer($validator, $handler);\n\n// Generates a response containing the basic outcome operation result\n$response = $server-&gt;handle($request);\n</code></pre>"},{"location":"libraries/lib-lti1p3-basic-outcome/doc/tool/","title":"Basic Outcome Tool - Basic Outcome Service Client","text":"<p>How to use the BasicOutcomeServiceClient to perform authenticated basic outcome service calls as a tool.</p>"},{"location":"libraries/lib-lti1p3-basic-outcome/doc/tool/#features","title":"Features","text":"<p>This library provides a BasicOutcomeServiceClient (based on the LtiServiceClient) that allow the following outcome operations:</p> <ul> <li>read result</li> <li>replace result</li> <li>delete result</li> </ul>"},{"location":"libraries/lib-lti1p3-basic-outcome/doc/tool/#usage","title":"Usage","text":""},{"location":"libraries/lib-lti1p3-basic-outcome/doc/tool/#read-a-result","title":"Read a result","text":"<pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3BasicOutcome\\Service\\Client\\BasicOutcomeServiceCLient;\nuse OAT\\Library\\Lti1p3Core\\Message\\Payload\\LtiMessagePayloadInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n// Related registration\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Related LTI 1.3 message payload\n/** @var LtiMessagePayloadInterface $payload */\n$payload  = ...;\n\n$client = new BasicOutcomeServiceCLient();\n\n$response = $client-&gt;readResultForPayload(\n    $registration, // [required] as the tool, it will call the platform of this registration\n    $payload       // [required] for the LTI message payload containing the basic outcome claim result sourced id (got at LTI launch)\n);\n\n// you also can directly read a result for a given basic outcome claim\n$response = $client-&gt;readResultForClaim(\n    $registration,               // [required] as the tool, it will call the platform of this registration\n    $payload-&gt;getBasicOutcome()  // [required] for the basic outcome claim result sourced id (got at LTI launch)\n);\n\n// or you also can directly read a result from given URL and result sourced id\n$response = $client-&gt;readResult(\n    $registration,                         // [required] as the tool, it will call the platform of this registration\n    'https://example.com/basic-outcome',   // [required] to a given basic outcome service url\n    'resultSourcedId'                      // [required] for a given result sourced id\n);\n\nif ($response-&gt;isSuccess()) {\n    // you can access the score\n    $score = $response-&gt;getScore();\n\n    // you can access the language\n    $language = $response-&gt;getLanguage();\n\n    // you can access the description of the operation\n    $description = $response-&gt;getDescription();\n\n    // you can also access if needed basic outcome response metadata\n    $identifier = $response-&gt;getIdentifier();\n    $refIdentifier = $response-&gt;getReferenceRequestIdentifier();\n    $refType = $response-&gt;getReferenceRequestType();\n}\n</code></pre>"},{"location":"libraries/lib-lti1p3-basic-outcome/doc/tool/#replace-a-result","title":"Replace a result","text":"<pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3BasicOutcome\\Service\\Client\\BasicOutcomeServiceCLient;\nuse OAT\\Library\\Lti1p3Core\\Message\\Payload\\LtiMessagePayloadInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n// Related registration\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Related LTI 1.3 message payload\n/** @var LtiMessagePayloadInterface $payload */\n$payload  = ...;\n\n$client = new BasicOutcomeServiceCLient();\n\n$response = $client-&gt;replaceResultForPayload(\n    $registration, // [required] as the tool, it will call the platform of this registration\n    $payload,      // [required] for the LTI message payload containing the basic outcome claim result sourced id (got at LTI launch)\n    0.42,          // [required] for a given score\n    'en'           // [optional] for a given language\n);\n\n// you also can directly replace a result for a given basic outcome claim, score and language\n$response = $client-&gt;replaceResultForClaim(\n    $registration,                // [required] as the tool, it will call the platform of this registration\n    $payload-&gt;getBasicOutcome(),  // [required] for the basic outcome claim result sourced id (got at LTI launch)\n    0.42,                         // [required] for a given score\n    'en'                          // [optional] for a given language\n);\n\n// or you also can directly replace a result on given URL, result sourced id, score and language\n$response = $client-&gt;replaceResult(\n    $registration,                         // [required] as the tool, it will call the platform of this registration\n    'https://example.com/basic-outcome',   // [required] to a given basic outcome service url\n    'resultSourcedId',                     // [required] for a given result sourced id\n    0.42,                                  // [required] for a given score\n    'en'                                   // [optional] for a given language\n);\n\nif ($response-&gt;isSuccess()) {\n    // you can access the description of the operation\n    $description = $response-&gt;getDescription();\n\n    // you can also access if needed basic outcome response metadata\n    $identifier = $response-&gt;getIdentifier();\n    $refIdentifier = $response-&gt;getReferenceRequestIdentifier();\n    $refType = $response-&gt;getReferenceRequestType();\n}\n</code></pre>"},{"location":"libraries/lib-lti1p3-basic-outcome/doc/tool/#delete-a-result","title":"Delete a result","text":"<pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3BasicOutcome\\Service\\Client\\BasicOutcomeServiceCLient;\nuse OAT\\Library\\Lti1p3Core\\Message\\Payload\\LtiMessagePayloadInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n// Related registration\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Related LTI 1.3 message payload\n/** @var LtiMessagePayloadInterface $payload */\n$payload  = ...;\n\n$client = new BasicOutcomeServiceCLient();\n\n$response = $client-&gt;deleteResultForPayload(\n    $registration, // [required] as the tool, it will call the platform of this registration\n    $payload       // [required] for the LTI message payload containing the basic outcome claim result sourced id (got at LTI launch)\n);\n\n// you also can directly delete a result for a given basic outcome claim\n$response = $client-&gt;deleteResultForClaim(\n    $registration,                // [required] as the tool, it will call the platform of this registration\n    $payload-&gt;getBasicOutcome()   // [required] for the basic outcome claim result sourced id (got at LTI launch)\n);\n\n// or you also can directly delete a result on given URL and result sourced id\n$response = $client-&gt;deleteResult(\n    $registration,                         // [required] as the tool, it will call the platform of this registration\n    'https://example.com/basic-outcome',   // [required] to a given basic outcome service url\n    'resultSourcedId'                      // [required] for a given result sourced id\n);\n\nif ($response-&gt;isSuccess()) {\n    // you can access the description of the operation\n    $description = $response-&gt;getDescription();\n\n    // you can also access if needed basic outcome response metadata\n    $identifier = $response-&gt;getIdentifier();\n    $refIdentifier = $response-&gt;getReferenceRequestIdentifier();\n    $refType = $response-&gt;getReferenceRequestType();\n}\n</code></pre>"},{"location":"libraries/lib-lti1p3-core/","title":"TAO - LTI 1.3 Core Library","text":"<p>IMS certified PHP library for LTI 1.3 Core implementations as platforms and / or as tools.</p>"},{"location":"libraries/lib-lti1p3-core/#ims","title":"IMS","text":"<p>You can find below IMS related information.</p>"},{"location":"libraries/lib-lti1p3-core/#related-certifications","title":"Related certifications","text":"<ul> <li>LTI 1.3 advantage complete</li> <li>LTI 1.3 proctoring services</li> </ul>"},{"location":"libraries/lib-lti1p3-core/#related-specifications","title":"Related specifications","text":"<ul> <li>IMS LTI 1.3 Core</li> <li>IMS Security</li> </ul>"},{"location":"libraries/lib-lti1p3-core/#installation","title":"Installation","text":"<pre><code>$ composer require oat-sa/lib-lti1p3-core\n</code></pre>"},{"location":"libraries/lib-lti1p3-core/#documentation","title":"Documentation","text":"<p>You can find below the library documentation, presented by topics.</p>"},{"location":"libraries/lib-lti1p3-core/#quick-start","title":"Quick start","text":"<ul> <li>how to configure the core library</li> <li>how to implement the core library interfaces</li> <li>how to expose a JWKS endpoint</li> </ul>"},{"location":"libraries/lib-lti1p3-core/#messages-interactions","title":"Messages interactions","text":"<ul> <li>how to handle platform originating LTI messages</li> <li>how to handle tool originating LTI messages</li> </ul>"},{"location":"libraries/lib-lti1p3-core/#services-interactions","title":"Services interactions","text":"<ul> <li>how to set up an LTI service server</li> <li>how to use the LTI service client</li> </ul>"},{"location":"libraries/lib-lti1p3-core/#wiki","title":"Wiki","text":"<p>You can find more information in the library wiki. </p>"},{"location":"libraries/lib-lti1p3-core/#tests","title":"Tests","text":"<p>To run tests:</p> <p><pre><code>$ vendor/bin/phpunit\n</code></pre> Note: see phpunit.xml.dist for available test suites.</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/","title":"Platform originating LTI messages","text":"<p>How to perform secured platform originating LTI messages launches (platform -&gt; tool), complying to the OIDC launch flow.</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#oidc-flow","title":"OIDC flow","text":"<p>Platform originating messages must comply to the OpenId Connect launch flow.</p> <p>You can find below an OIDC launch flow diagram, with steps numbers:</p> <p></p> <p>To handle the OIDC launch flow for platform originating messages, each step will be detailed below, from both platform and tool perspectives.</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#1-platform-side-launch-generation","title":"1 - Platform side: launch generation","text":"<p>You can find below required steps to generate a platform originating message, needed only if you're acting as a platform.</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#create-the-message","title":"Create the message","text":"<p>As a platform, you can create a platform originating message for a tool within the context of a registration.</p> <p>To do so, you can use the PlatformOriginatingLaunchBuilder: <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Builder\\PlatformOriginatingLaunchBuilder;\nuse OAT\\Library\\Lti1p3Core\\Message\\LtiMessageInterface;\nuse OAT\\Library\\Lti1p3Core\\Message\\Payload\\Claim\\ContextClaim;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n// Create a builder instance\n$builder = new PlatformOriginatingLaunchBuilder();\n\n// Get related registration of the launch\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Build a launch message\n$message = $builder-&gt;buildPlatformOriginatingLaunch(\n    $registration,                                               // related registration\n    LtiMessageInterface::LTI_MESSAGE_TYPE_RESOURCE_LINK_REQUEST, // message type of the launch, as an example: 'LtiDeepLinkingResponse'\n    'http://tool.com/launch',                                    // target link uri of the launch (final destination after OIDC flow)\n    'loginHint',                                                 // login hint that will be used afterwards by the platform to perform authentication\n    null,                                                        // will use the registration default deployment id, but you can pass a specific one\n    [\n        'http://purl.imsglobal.org/vocab/lis/v2/membership#Learner' // role\n    ],\n    [\n        'myCustomClaim' =&gt; 'myCustomValue',    // custom claim\n        new ContextClaim('contextIdentifier')  // LTI claim representing the context of the launch \n    ]\n);\n</code></pre> Note: like the <code>ContextClaim</code> class, any claim that implement the MessagePayloadClaimInterface will be automatically normalized and added to the message payload claims.</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#launch-the-message","title":"Launch the message","text":"<p>As a result of the build, you get a LtiMessageInterface instance that has to be used in the following ways:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\LtiMessageInterface;\n\n/** @var LtiMessageInterface $message */\n\n// Main message properties you can use as you want to offer the launch to the platform users\necho $message-&gt;getUrl();               // url of the launch\necho $message-&gt;getParameters()-&gt;all(); // array of parameters of the launch\n\n// Or use those helpers methods to ease the launch interactions\necho $message-&gt;toUrl();                // url with launch parameters as query parameters\necho $message-&gt;toHtmlLink('click me'); // HTML link, where href is the output url\necho $message-&gt;toHtmlRedirectForm();   // HTML hidden form, with possibility of auto redirection\n</code></pre>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#launching-an-lti-resource-link","title":"Launching an LTI Resource Link","text":"<p>This library also allow you to perform easily launches of an LTI Resource Link.</p> <p>This becomes handy when a platform owns an LTI Resource Link to a tool resource (previously fetched with DeepLinking for example).</p> <p>First of all, you need to create or retrieve an LtiResourceLink instance: <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Resource\\LtiResourceLink\\LtiResourceLink;\n\n$ltiResourceLink = new LtiResourceLink(\n    'resourceLinkIdentifier',\n    [\n        'url' =&gt; 'http://tool.com/resource',\n        'title' =&gt; 'Some title'\n    ]\n);\n</code></pre></p> <p>Once your <code>LtiResourceLinkInterface</code> implementation is ready, you can use the LtiResourceLinkLaunchRequestBuilder to create an LTI Resource Link launch:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Builder\\LtiResourceLinkLaunchRequestBuilder;\nuse OAT\\Library\\Lti1p3Core\\Message\\Payload\\Claim\\ContextClaim;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n// Create a builder instance\n$builder = new LtiResourceLinkLaunchRequestBuilder();\n\n// Get related registration of the launch\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Build a launch message\n$message = $builder-&gt;buildLtiResourceLinkLaunchRequest(\n    $ltiResourceLink, // LTI resource link to launch\n    $registration,    // related registration\n    'loginHint',      // hint about the user login process that will be done on a later step\n    null,             // will use the registration default deployment id, but you can pass a specific one\n    [\n        'http://purl.imsglobal.org/vocab/lis/v2/membership#Learner' // role\n    ], \n    [\n        new ContextClaim('contextId'),     // LTI claim representing the context \n        'myCustomClaim' =&gt; 'myCustomValue' // custom claim\n    ]\n);\n</code></pre> <p>As it also returns an LtiMessageInterface instance, you can then use the generated message to launch it as explained previously.</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#2-tool-side-oidc-initiation","title":"2 - Tool side: OIDC initiation","text":"<p>You can find below required steps to handle the initiation an OIDC flow, needed only if you're acting as a tool.</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#handling-the-oidc-initiation","title":"Handling the OIDC initiation","text":"<p>As a tool, you'll receive an HTTP request containing the OIDC initiation, generated by the platform originating messages builders.</p> <p>You can use the OidcInitiator to handle this:</p> <ul> <li>it requires a registration repository implementation as explained here</li> <li>it expects a PSR7 ServerRequestInterface to handle</li> <li>it will output a LtiMessageInterface instance to be sent back to the platform.</li> </ul> <p>For example: <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Oidc\\OidcInitiator;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n// Create the OIDC initiator\n$initiator = new OidcInitiator($registrationRepository);\n\n// Perform the OIDC initiation (including state generation)\n$message = $initiator-&gt;initiate($request);\n\n// Redirection to the platform\nheader('Location: ' . $message-&gt;toUrl(), true, 302);\ndie;\n</code></pre></p>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#oidc-initiation-redirection-automation","title":"OIDC initiation redirection automation","text":"<p>This library provides the OidcInitiationRequestHandler, implementing the PSR15 RequestHandlerInterface, that can be exposed in an application controller to automate a redirect response creation from the OidcInitiator output:</p> <ul> <li>it expects a PSR7 ServerRequestInterface to handle</li> <li>it will return a PSR7 ResponseInterface instance to make the redirection to the platform.</li> </ul> <p>For example:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Oidc\\OidcInitiator;\nuse OAT\\Library\\Lti1p3Core\\Security\\Oidc\\Server\\OidcInitiationRequestHandler;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n// Create the OIDC initiation handler\n$handler = new OidcInitiationRequestHandler(new OidcInitiator($registrationRepository));\n\n// Redirect response from OIDC initiation (including state &amp; nonce generation, via 302)\n$response = $handler-&gt;handle($request);\n</code></pre>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#3-platform-side-oidc-authentication","title":"3 - Platform side: OIDC authentication","text":"<p>You can find below required steps to provide authentication during the OIDC flow, needed only if you're acting as a platform.</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#perform-the-oidc-authentication-and-redirecting-to-the-tool","title":"Perform the OIDC authentication and redirecting to the tool","text":"<p>After the redirection of the tool to the platform, the platform need to provide authentication and redirect to the tool to continue the OIDC flow.</p> <p>It can be handled with the OidcAuthenticator:</p> <ul> <li>it requires a registration repository and a UserAuthenticatorInterface implementation as explained here</li> <li>it expects a PSR7 ServerRequestInterface to handle</li> <li>it will output a LtiMessageInterface that can be used to redirect to the tool to finish the OIDC flow.</li> </ul> <p>You have to specify how to provide platform authentication, for example:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\User\\UserAuthenticatorInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\User\\Result\\UserAuthenticationResult;\nuse OAT\\Library\\Lti1p3Core\\Security\\User\\Result\\UserAuthenticationResultInterface;\nuse OAT\\Library\\Lti1p3Core\\User\\UserIdentity;\n\n$userAuthenticator = new class implements UserAuthenticatorInterface\n{\n   public function authenticate(\n       RegistrationInterface $registration,\n       string $loginHint\n   ): UserAuthenticationResultInterface {\n       // Perform user authentication based on the registration, request or login hint\n       // (ex: owned session, LDAP, external auth service, etc)\n       ...       \n\n        return new UserAuthenticationResult(\n           true,                                          // success\n           new UserIdentity('userIdentifier', 'userName') // authenticated user identity\n       );   \n   }\n};\n</code></pre> <p>To then use it to continue OIDC fow:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Oidc\\OidcAuthenticator;\nuse OAT\\Library\\Lti1p3Core\\Security\\User\\UserAuthenticatorInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var UserAuthenticatorInterface $userAuthenticator */\n$userAuthenticator = ...\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n// Create the OIDC authenticator\n$authenticator = new OidcAuthenticator($registrationRepository, $userAuthenticator);\n\n// Perform the login authentication (delegating to the $userAuthenticator with the hint 'loginHint')\n$message = $authenticator-&gt;authenticate($request);\n\n// Auto redirection to the tool via the user's browser\necho $message-&gt;toHtmlRedirectForm();\n</code></pre>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#oidc-authentication-redirection-automation","title":"OIDC authentication redirection automation","text":"<p>This library provides the OidcAuthenticationRequestHandler, implementing the PSR15 RequestHandlerInterface, that can be exposed in an application controller to automate a redirect form response creation from the OidcAuthenticator output:</p> <ul> <li>it expects a PSR7 ServerRequestInterface to handle</li> <li>it will return a PSR7 ResponseInterface instance to make the redirection to the tool via a form POST.</li> </ul> <p>For example:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Oidc\\OidcAuthenticator;\nuse OAT\\Library\\Lti1p3Core\\Security\\Oidc\\Server\\OidcAuthenticationRequestHandler;\nuse OAT\\Library\\Lti1p3Core\\Security\\User\\UserAuthenticatorInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var UserAuthenticatorInterface $userAuthenticator */\n$userAuthenticator = ...\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n// Create the OIDC authentication handler\n$handler = new OidcAuthenticationRequestHandler(new OidcAuthenticator($registrationRepository, $userAuthenticator));\n\n// Redirect response from OIDC authentication (via form POST)\n$response = $handler-&gt;handle($request);\n</code></pre>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#4-tool-side-launch-validation","title":"4 - Tool side: launch validation","text":"<p>You can find below required steps to validate a platform originating message launch after OIDC flow, needed only if you're acting as a tool.</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#validate-the-launch","title":"Validate the launch","text":"<p>As a tool, you'll receive an HTTP request containing the launch message after OIDC flow completion.</p> <p>The ToolLaunchValidator can be used for this:</p> <ul> <li>it requires a registration repository and a nonce repository implementations as explained here</li> <li>it expects a PSR7 ServerRequestInterface to validate</li> <li>it will output a LaunchValidationResultInterface representing the launch validation, the related registration and the message payload itself.</li> </ul> <p>For example: <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\Tool\\ToolLaunchValidator;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Nonce\\NonceRepositoryInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var NonceRepositoryInterface $nonceRepository */\n$nonceRepository = ...\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n// Create the validator\n$validator = new ToolLaunchValidator($registrationRepository, $nonceRepository);\n\n// Perform validation\n$result = $validator-&gt;validatePlatformOriginatingLaunch($request);\n\n// Result exploitation\nif (!$result-&gt;hasError()) {\n    // You have access to related registration (to spare queries)\n    echo $result-&gt;getRegistration()-&gt;getIdentifier();\n\n    // And to the LTI message payload (id_token parameter)\n    echo $result-&gt;getPayload()-&gt;getVersion();                  // '1.3.0'\n    echo $result-&gt;getPayload()-&gt;getContext()-&gt;getIdentifier(); // 'contextIdentifier'\n    echo $result-&gt;getPayload()-&gt;getClaim('myCustomClaim');     // 'myCustomValue'\n    echo $result-&gt;getPayload()-&gt;getUserIdentity()-&gt;getName();  // 'userName', see platform during OIDC authentication\n\n    // If needed, you can also access the OIDC state (state parameter)\n    echo $result-&gt;getState()-&gt;getToken()-&gt;toString();              // state JWT\n    echo $result-&gt;getState()-&gt;getToken()-&gt;getClaims()-&gt;get('jti'); // state JWT id\n\n    // If needed, you can also access the validation successes\n    foreach ($result-&gt;getSuccesses() as $success) {\n        echo $success;\n    }\n} \n</code></pre></p> <p>Note: if you want to work with the message payload claims as array of values (for caching purposes for example), you can use the MessagePayloadClaimsExtractor for extracting claims (provides a configurable claim sanitization).</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/platform-originating-messages/#working-with-launch-roles","title":"Working with launch roles","text":"<p>The LtiMessagePayloadInterface provides the <code>getValidatedRoleCollection()</code> getter to allow you to work easily with the LTI specification roles as a RoleCollection.</p> <p>You can base yourself on this collection if you need to perform RBAC on tool side, for example:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\Result\\LaunchValidationResult;\nuse OAT\\Library\\Lti1p3Core\\Role\\RoleInterface;\n\n/** @var LaunchValidationResult $result */\n$result = $validator-&gt;validatePlatformOriginatingLaunch(...);\n\n// Result exploitation\nif (!$result-&gt;hasError()) {\n\n    // Access the validated role collection\n    $roles = $result-&gt;getPayload()-&gt;getValidatedRoleCollection();\n\n    // Check if a role of type context (core or not) has been provided (our case for http://purl.imsglobal.org/vocab/lis/v2/membership#Learner)\n    if ($roles-&gt;canFindBy(RoleInterface::TYPE_CONTEXT)) {\n        // Authorized launch\n        ...\n    } else {\n        // Unauthorized launch\n        ...\n    }\n} \n</code></pre> <p>Notes: </p> <ul> <li>if the launch contains invalid (non respecting LTI specification) roles, the getter will throw an LtiException</li> <li>the LtiMessagePayloadInterface offers the <code>getRoles()</code> getter to work with plain roles values (no validation)</li> </ul>"},{"location":"libraries/lib-lti1p3-core/doc/message/tool-originating-messages/","title":"Tool originating LTI messages","text":"<p>How to perform secured tool originating LTI messages launches (tool -&gt; platform).</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/tool-originating-messages/#flow","title":"Flow","text":"<p>Each step will be detailed below, from both tool and platform perspectives.</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/tool-originating-messages/#1-tool-side-launch-generation","title":"1 - Tool side: launch generation","text":"<p>You can find below required steps to generate a tool originating message, needed only if you're acting as a tool.</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/tool-originating-messages/#create-the-message","title":"Create the message","text":"<p>As a tool, you can create a tool originating message for a platform within the context of a registration.</p> <p>To do so, you can use the ToolOriginatingLaunchBuilder: <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Builder\\ToolOriginatingLaunchBuilder;\nuse OAT\\Library\\Lti1p3Core\\Message\\LtiMessageInterface;\nuse OAT\\Library\\Lti1p3Core\\Message\\Payload\\Claim\\DeepLinkingContentItemsClaim;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n// Create a builder instance\n$builder = new ToolOriginatingLaunchBuilder();\n\n// Get related registration of the launch\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Build a launch message\n$message = $builder-&gt;buildToolOriginatingLaunch(\n    $registration,                                               // related registration\n    LtiMessageInterface::LTI_MESSAGE_TYPE_DEEP_LINKING_RESPONSE, // message type of the launch, as an example: 'LtiDeepLinkingResponse'\n    'http://platform.com/launch',                                // platform launch url\n    null,                                                        // will use the registration default deployment id, but you can pass a specific one\n    [\n        'myCustomClaim' =&gt; 'myCustomValue',                      // custom claim\n        new DeepLinkingContentItemsClaim(...)                    // LTI claim representing the DeepLinking returned resources \n    ]\n);\n</code></pre> Note: like the <code>DeepLinkingContentItemsClaim</code> class, any claim that implement the MessagePayloadClaimInterface will be automatically normalized and added to the message payload claims.</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/tool-originating-messages/#launch-the-message","title":"Launch the message","text":"<p>As a result of the build, you get a LtiMessageInterface instance that has to be used this way (form POST into <code>JWT</code> parameter):</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\LtiMessageInterface;\n\n// Auto redirection from the tool to the platform via the user's browser\n/** @var LtiMessageInterface $message */\necho $message-&gt;toHtmlRedirectForm();\n</code></pre>"},{"location":"libraries/lib-lti1p3-core/doc/message/tool-originating-messages/#2-platform-side-launch-validation","title":"2 - Platform side: launch validation","text":"<p>You can find below required steps to validate a tool originating message launch, needed only if you're acting as a platform.</p>"},{"location":"libraries/lib-lti1p3-core/doc/message/tool-originating-messages/#validate-the-launch","title":"Validate the launch","text":"<p>As a platform, you'll receive an HTTP request containing the launch message.</p> <p>The PlatformLaunchValidator can be used for this:</p> <ul> <li>it requires a registration repository and a nonce repository implementations as explained here</li> <li>it expects a PSR7 ServerRequestInterface to validate</li> <li>it will output a LaunchValidationResultInterface representing the launch validation, the related registration and the message payload itself.</li> </ul> <p>For example: <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\PLatform\\PlatformLaunchValidator;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Nonce\\NonceRepositoryInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var NonceRepositoryInterface $nonceRepository */\n$nonceRepository = ...\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n// Create the validator\n$validator = new PlatformLaunchValidator($registrationRepository, $nonceRepository);\n\n// Perform validation\n$result = $validator-&gt;validateToolOriginatingLaunch($request);\n\n// Result exploitation\nif (!$result-&gt;hasError()) {\n    // You have access to related registration (to spare queries)\n    echo $result-&gt;getRegistration()-&gt;getIdentifier();\n\n    // And to the LTI message payload (JWT parameter)\n    echo $result-&gt;getPayload()-&gt;getVersion();                 // '1.3.0'\n    echo $result-&gt;getPayload()-&gt;getMessageType();             // 'LtiDeepLinkingResponse'\n    echo $result-&gt;getPayload()-&gt;getClaim('myCustomClaim');    // 'myCustomValue'\n\n    // You can iterate on the example DeepLinking response content items\n    foreach ($result-&gt;getPayload()-&gt;getDeepLinkingContentItems()-&gt;getContentItems() as $item) {\n        ...\n    }\n\n    // If needed, you can also access the validation successes\n    foreach ($result-&gt;getSuccesses() as $success) {\n        echo $success;\n    }\n} \n</code></pre></p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/configuration/","title":"Core library configuration","text":"<p>How to provide configuration step by step, to be able to use the library as a tool, or a platform, or both.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/configuration/#configure-security-keys","title":"Configure security keys","text":"<p>Whether you act as platform, tool or both, you need to provide security keys to be able to sign the messages that will be exchanged during LTI interactions.</p> <p>Considering you have for example on your side this key chain:</p> <ul> <li>public key path: <code>/home/user/.ssh/id_rsa.pub</code></li> <li>private key path: <code>/home/user/.ssh/id_rsa</code></li> <li>private key passphrase: <code>test</code></li> </ul> <p>You can then use the provided KeyChainFactory to build your security keys:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Security\\Key\\KeyChainFactory;\nuse OAT\\Library\\Lti1p3Core\\Security\\Key\\KeyInterface;\n\n$keyChain = (new KeyChainFactory)-&gt;create(\n    '1',                                // [required] identifier (used for JWT kid header)\n    'mySetName',                        // [required] key set name (for grouping)\n    'file://home/user/.ssh/id_rsa.pub', // [required] public key (file or content)\n    'file://home/user/.ssh/id_rsa',     // [optional] private key (file or content)\n    'test',                             // [optional] private key passphrase (if existing)\n     KeyInterface::ALG_RS256            // [optional] algorithm (default: RS256)\n);\n</code></pre> <p>Notes:</p> <ul> <li>given example deals with local key files, automatically done when prefixed by <code>file://</code></li> <li>you can provide the public / private key stream content or JWK array values by passing them as a constructor argument instead (if you want to fetch your keys from a bucket file or a JWKS endpoint for example)</li> <li>by default the <code>RS256</code> will be used, but you can provide others listed here</li> </ul> <p>As a result, you'll get a KeyChainInterface instance:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Security\\Key\\KeyChainInterface;\n\n/** @var KeyChainInterface $keyChain */\necho $keyChain-&gt;getIdentifier();                   // '1'\necho $keyChain-&gt;getPublicKey()-&gt;getContent();      // public key content\necho $keyChain-&gt;getPublicKey()-&gt;getAlgorithm();    // 'RS256'\nvar_dump($keyChain-&gt;getPublicKey()-&gt;isFromFile()); // true\n</code></pre>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/configuration/#configure-a-platform","title":"Configure a platform","text":"<p>You need to provide configuration for the platform:</p> <ul> <li>you are representing if you use the library from platform side</li> <li>where your tool is deployed on, if you use the library from tool side</li> </ul> <p>For example: <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Platform\\Platform;\n\n$platform = new Platform(\n    'platformIdentifier',                       // [required] identifier\n    'platformName',                             // [required] name\n    'https://platform.com',                     // [required] audience\n    'https://platform.com/oidc-auth',           // [optional] OIDC authentication url\n    'https://platform.com/oauth2-access-token'  // [optional] OAuth2 access token url\n);\n</code></pre> Note: you can also provide your own implementation of the PlatformInterface.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/configuration/#configure-a-tool","title":"Configure a tool","text":"<p>You need to provide configuration for the tool:</p> <ul> <li>you are representing if you use the library from tool side</li> <li>you want to provide functionality from, if you use the library from platform side</li> </ul> <p>For example: <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Tool\\Tool;\n\n$tool = new Tool(\n    'toolIdentifier',               // [required] identifier\n    'toolName',                     // [required] name\n    'https://tool.com',             // [required] audience\n    'https://tool.com/oidc-init',   // [required] OIDC initiation url\n    'https://tool.com/launch',      // [optional] default tool launch url\n    'https://tool.com/deep-linking' // [optional] DeepLinking url\n);\n</code></pre> Note: you can also provide your own implementation of the ToolInterface.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/configuration/#configure-a-registration","title":"Configure a registration","text":"<p>You need then to create a registration, describing how the tool is made available for the platform.</p> <p>A same platform instance can deploy several tools (or several times the same tool instance), that is why this binding is handled on the deployment ids level.</p> <p>For example: <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\Registration;\n\n$registration = new Registration(\n    'registrationIdentifier',  // [required] identifier\n    'registrationClientId',    // [required] client id\n    $platform,                 // [required] (PlatformInterface) platform \n    $tool,                     // [required] (ToolInterface) tool \n    $deploymentIds,            // [required] (array) deployments ids \n    $platformKeyChain,         // [optional] (KeyChainInterface) key chain of the platform \n    $toolKeyChain,             // [optional] (KeyChainInterface) key chain of the tool \n    $platformJwksUrl,          // [optional] JWKS url of the platform\n    $toolJwksUrl,              // [optional] JWKS url of the tool\n);\n</code></pre> Notes:</p> <ul> <li>you can also provide your own implementation of the RegistrationInterface</li> <li>depending on the side you act (platform or tool), you need to configure what is relevant regarding the keys and the JWKS urls</li> <li>since you should be in control of the way you retrieve your registrations configuration (from YML files, array, database, etc), you have to provide your own implementation of the RegistrationRepositoryInterface to fit your needs</li> </ul>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/configuration/#public-key-versus-jwks","title":"Public key versus JWKS","text":"<p>On a registration creation, you can give both JWKS url and public key for the tool and platform.</p> <p>To be optimal for signature verification:</p> <ul> <li>if both JWKS and public key given, the library will always use the public key (to avoid JWKS calls)</li> <li>if only one of them given, it'll use the given one</li> <li>if none given, it'll throw an error (unable to validate calls)</li> </ul> <p>Using JWKS is recommended (but not mandatory):</p> <ul> <li>it avoids keys exchange / maintenance processes, and allow easier integrations (keys can rotate, JWKS url remains the same)</li> <li>it handles automatically caching (to avoid useless traffic), see possibility to inject a PSR6 cache into the JwksFetcher</li> </ul> <p>Depending on the side you're acting on, you need to provide a <code>KeyChainInterface</code> instance that contains a public key and it's associated private key (and passphrase).</p> <p>For example, if you're acting as a platform:</p> <ul> <li>the <code>$platformKeyChain</code> has to be given, containing public &amp; private keys (to sign platform originating messages)</li> <li>either the <code>$toolKeyChain</code> (with only a public key) or the <code>$toolJwksUrl</code> has to be given to validate tool originating messages</li> </ul> <p>Or, if you're acting as a tool:</p> <ul> <li>the <code>$toolKeyChain</code> has to be given, containing public &amp; private keys (to sign tool originating messages)</li> <li>either the <code>$platformKeyChain</code> (with only a public key) or the <code>$platformJwksUrl</code> has to be given to validate platform originating messages</li> </ul>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/","title":"Core library interfaces","text":"<p>Depending on the top level services you want to use, you have to provide your own implementation of the following interfaces.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#mandatory-interfaces","title":"Mandatory interfaces","text":"<p>This section present the mandatory interfaces from the library to be implemented to use provided services.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#registration-repository-interface","title":"Registration repository interface","text":"<p>Required by: - Message - Service</p> <p>In order to be able to retrieve your registrations from your configuration storage, you need to provide an implementation of the RegistrationRepositoryInterface.</p> <p>For example: <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\n\n$registrationRepository = new class implements RegistrationRepositoryInterface\n{\n   public function find(string $identifier): ?RegistrationInterface\n   {\n       // TODO: Implement find() method to find a registration by identifier, or null if not found.\n   }\n\n   public function findAll(): array\n   {\n       // TODO: Implement findAll() method to find all available registrations.\n   }\n\n   public function findByClientId(string $clientId) : ?RegistrationInterface\n   {\n       // TODO: Implement findByClientId() method to find a registration by client id, or null if not found.\n   }\n\n   public function findByPlatformIssuer(string $issuer, string $clientId = null): ?RegistrationInterface\n   {\n        // TODO: Implement findByPlatformIssuer() method to find a registration by platform issuer, and client id if provided.\n   }\n\n   public function findByToolIssuer(string $issuer, string $clientId = null): ?RegistrationInterface\n   {\n        // TODO: Implement findByToolIssuer() method to find a registration by tool issuer, and client id if provided.\n   }\n};\n</code></pre> Note: you can find a simple implementation example of this interface in the method <code>createTestRegistrationRepository()</code> of the DomainTestingTrait.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#user-authenticator-interface","title":"User authenticator interface","text":"<p>Required by: Message </p> <p>During the OIDC authentication handling on the platform side, you need to define how to delegate the user authentication by providing an implementation of the UserAuthenticatorInterface.</p> <p>For example:</p> <p><pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\User\\UserAuthenticatorInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\User\\Result\\UserAuthenticationResultInterface;\n\n$userAuthenticator = new class implements UserAuthenticatorInterface\n{\n   public function authenticate(\n       RegistrationInterface $registration,\n       string $loginHint\n   ): UserAuthenticationResultInterface {\n       // TODO: Implement authenticate() method to perform user authentication (ex: session, LDAP, etc)\n   }\n};\n</code></pre> Notes:</p> <ul> <li>you can find a simple implementation example of this interface in the method <code>createTestUserAuthenticator()</code> of the SecurityTestingTrait.</li> <li>you can find a ready to use <code>UserAuthenticationResultInterface</code> implementation is available in UserAuthenticationResult</li> </ul>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#optional-interfaces","title":"Optional interfaces","text":"<p>This section present the optional interfaces from the library you can implement, but for which a default implementation is already provided.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#nonce-repository-interface","title":"Nonce repository interface","text":"<p>Default implementation: NonceRepository</p> <p>In order to be able to store security nonce the way you want, you can provide an implementation of the NonceRepositoryInterface.</p> <p>For example: <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Security\\Nonce\\NonceInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Nonce\\NonceRepositoryInterface;\n\n$nonceRepository = new class implements NonceRepositoryInterface\n{\n    public function find(string $value) : ?NonceInterface\n    {\n        // TODO: Implement find() method to find a nonce by value, or null if not found.\n    }\n\n    public function save(NonceInterface $nonce) : void\n    {\n        // TODO: Implement save() method to save a nonce (cache, database, etc)\n    }\n};\n</code></pre> Note: the ready to use NonceRepository works with a PSR6 cache.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#jwks-fetcher-interface","title":"JWKS fetcher interface","text":"<p>Default implementation: JwksFetcher</p> <p>In order to be able to fetch public keys JWK from configured JWKS endpoint, you need to provide an implementation of the JwksFetcherInterface.</p> <p>For example: <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Security\\Jwks\\Fetcher\\JwksFetcherInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Key\\KeyInterface;\n\n$fetcher = new class implements JwksFetcherInterface\n{\n    public function fetchKey(string $jwksUrl, string $kId) : KeyInterface\n    {\n        // TODO: Implement fetchKey() method to find a Key via an HTTP call to the $jwksUrl, for the kid $kId.\n    }\n};\n</code></pre> Notes:</p> <ul> <li>it is recommended to put in cache the JWKS endpoint responses, to improve performances since they don't change often. Your implementation can then rely on a cache by example.</li> <li>the ready to use JwksFetcher works with a guzzle client to request JWKS data, a PSR6 cache to cache them, and a PSR3 logger to log this process.</li> </ul>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#lti-platform-message-launch-validator-interface","title":"LTI platform message launch validator interface","text":"<p>Default implementation: PlatformLaunchValidator</p> <p>To customise platform message launch validation, an implementation of the PlatformLaunchValidatorInterface can be provided.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#lti-tool-message-launch-validator-interface","title":"LTI tool message launch validator interface","text":"<p>Default implementation: ToolLaunchValidator</p> <p>To customise tool message launch validation, an implementation of the ToolLaunchValidatorInterface can be provided.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#lti-service-client-interface","title":"LTI service client interface","text":"<p>Default implementation: LtiServiceClient </p> <p>In order to send authenticated service calls, an implementation of the LtiServiceClientInterface can be provided.</p> <p>For example:</p> <p><pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Service\\Client\\LtiServiceClientInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationInterface;  \nuse Psr\\Http\\Message\\ResponseInterface;\n\n$client = new class implements LtiServiceClientInterface\n{\n    public function request(RegistrationInterface $registration, string $method, string $uri, array $options = [], array $scopes = []) : ResponseInterface\n    {\n        // TODO: Implement request() method to manage authenticated calls to services.\n    }\n};\n</code></pre> Notes:    </p> <ul> <li>it is recommended to put in cache the service access tokens, to improve performances. Your implementation can then rely on an injected PSR6 cache by example.</li> </ul>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#lti-service-server-access-token-generator-interface","title":"LTI service server access token generator interface","text":"<p>Default implementation: AccessTokenResponseGenerator</p> <p>To customise access token generation, an implementation of the AccessTokenResponseGeneratorInterface can be provided.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#lti-service-server-access-token-validator-interface","title":"LTI service server access token validator interface","text":"<p>Default implementation: RequestAccessTokenValidator</p> <p>To customise access token validation, an implementation of the RequestAccessTokenValidatorInterface can be provided.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#lti-service-server-client-repository-interface","title":"LTI service server client repository interface","text":"<p>Default implementation: ClientRepository </p> <p>In order to retrieve and validate clients involved in authenticated service calls, an implementation of the ClientRepositoryInterface can be provided.</p> <p>Notes:</p> <ul> <li>the default <code>ClientRepository</code> injects the <code>RegistrationRepositoryInterface</code> to be able to expose your platforms as oauth2 providers and tools as consumers.</li> <li>in case of the consumer tool public key is not given in the registration, it will automatically fallback to a JWKS call.</li> </ul>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#lti-service-server-access-token-repository-interface","title":"LTI service server access token repository interface","text":"<p>Default implementation: AccessTokenRepository </p> <p>In order to store service calls access tokens, an implementation of the AccessTokenRepositoryInterface can be provided.</p> <p>Note: the default <code>AccessTokenRepository</code> implementation rely on a PSR6 cache to store generated access tokens.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#lti-service-server-scope-repository-interface","title":"LTI service server scope repository interface","text":"<p>Default implementation: ScopeRepository </p> <p>In order to retrieve and finalize scopes during grants, an implementation of the ScopeRepositoryInterface can be provided.</p> <p>Note:</p> <ul> <li>the default <code>ScopeRepository</code> will just provide back scopes given at construction.</li> </ul>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#id-generator-interface","title":"Id generator interface","text":"<p>Default implementation: IdGenerator</p> <p>To customise overall id generation, an implementation of the IdGeneratorInterface can be provided.</p> <p>Note:</p> <ul> <li>the default <code>IdGenerator</code> generates UUIDv4.</li> </ul>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#jwt-interface","title":"JWT interface","text":"<p>Default implementation: Token</p> <p>To customise JWT handling, an implementation of the TokenInterface can be provided.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#jwt-builder-interface","title":"JWT builder interface","text":"<p>Default implementation: Builder</p> <p>To customise JWT creation, an implementation of the BuilderInterface can be provided.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#jwt-parser-interface","title":"JWT parser interface","text":"<p>Default implementation: Parser</p> <p>To customise JWT parsing, an implementation of the ParserInterface can be provided.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/interfaces/#jwt-validator-interface","title":"JWT validator interface","text":"<p>Default implementation: Validator</p> <p>To customise JWT validation, an implementation of the ValidatorInterface can be provided.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/jwks/","title":"JWKS endpoint","text":"<p>How to expose a JWKS endpoint (JSON Web Key Set) with this library.</p> <p>Note: The algorithm <code>RS256</code> is used by default.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/jwks/#export-a-jwk-from-a-key-chain","title":"Export a JWK from a key chain","text":"<p>Considering you have for example on your side this key chain:</p> <ul> <li>public key path: <code>/home/user/.ssh/id_rsa.pub</code></li> <li>private key path: <code>/home/user/.ssh/id_rsa</code></li> <li>private key passphrase: <code>test</code></li> </ul> <p>To extract the JWK (JSON Web Key) properties, you can use the JwkRS256Exporter as following:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Security\\Jwks\\Exporter\\Jwk\\JwkRS256Exporter;\nuse OAT\\Library\\Lti1p3Core\\Security\\Key\\KeyChainFactory;\nuse OAT\\Library\\Lti1p3Core\\Security\\Key\\KeyInterface;\n\n$keyChain = (new KeyChainFactory)-&gt;create(\n    '1',\n    'mySetName',\n    'file://home/user/.ssh/id_rsa.pub',\n    'file://home/user/.ssh/id_rsa',\n    'test',\n     KeyInterface::ALG_RS256\n);\n\n$jwkExport = (new JwkRS256Exporter())-&gt;export($keyChain);\n</code></pre> <p>Notes: - the <code>$jwkExport</code> variable now contain the needed JWK properties:     <pre><code>{\n    \"alg\": \"RS256\",\n    \"kty\": \"RSA\",\n    \"use\": \"sig\",\n    \"n\": \"...\",\n    \"e\": \"...\",\n    \"kid\": \"1\"\n}\n</code></pre> - If you want to support other algorithms than RS256, you can implement the JwkExporterInterface.</p>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/jwks/#export-a-jwks-from-multiple-key-chains","title":"Export a JWKS from multiple key chains","text":"<p>Considering you have for example on your side those key chains:</p> <p>Chain 1: - public key path: <code>/home/user/.ssh/chain1/id_rsa.pub</code> - private key path: <code>/home/user/.ssh/chain1/id_rsa</code> - private key passphrase: <code>test1</code></p> <p>Chain 2: - public key path: <code>/home/user/.ssh/chain2/id_rsa.pub</code> - private key path: <code>/home/user/.ssh/chain2/id_rsa</code> - private key passphrase: <code>test2</code></p> <p>You can then use the KeyChainRepository:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Security\\Key\\KeyChainFactory;\nuse OAT\\Library\\Lti1p3Core\\Security\\Key\\KeyChainRepository;\nuse OAT\\Library\\Lti1p3Core\\Security\\Key\\KeyInterface;\n\n$keyChain1 = (new KeyChainFactory)-&gt;create(\n    'kid1',\n    'myKeySetName',\n    'file://home/user/.ssh/chain1/id_rsa.pub',\n    'file://home/user/.ssh/chain1/id_rsa',\n    'test1',\n     KeyInterface::ALG_RS256\n);\n\n$keyChain2 = (new KeyChainFactory)-&gt;create(\n    'kid2',\n    'myKeySetName',\n    'file://home/user/.ssh/chain2/id_rsa.pub',\n    'file://home/user/.ssh/chain2/id_rsa',\n    'test2',\n     KeyInterface::ALG_RS256\n);\n\n$keyChainRepository = new KeyChainRepository();\n$keyChainRepository\n    -&gt;addKeyChain($keyChain1)\n    -&gt;addKeyChain($keyChain2);\n\n$keySet = $keyChainRepository-&gt;findByKeySetName('myKeySetName'); //  = [$keyChain1, $keyChain2]\n</code></pre> <p>Note: you can also provide your own KeyChainRepositoryInterface implementation, to store keys in database by example.</p> <p>To extract the JWKS (JSON Web Key Set) properties for you key set name <code>myKeySetName</code>, you can use the JwksExporter as following:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Security\\Jwks\\Exporter\\JwksExporter;\n\n$jwksExport = (new JwksExporter($keyChainRepository))-&gt;export('myKeySetName');\n</code></pre> <p>Now the <code>$jwksExport</code> array contains the needed JWKS properties ready to be exposed to provide a JWKS endpoint from your application:</p> <pre><code>{\n    \"keys\": [\n        {\n            \"alg\": \"RS256\",\n            \"kty\": \"RSA\",\n            \"use\": \"sig\",\n            \"n\": \"...\",\n            \"e\": \"...\",\n            \"kid\": \"kid1\"\n        },\n        {\n            \"alg\": \"RS256\",\n            \"kty\": \"RSA\",\n            \"use\": \"sig\",\n            \"n\": \"...\",\n            \"e\": \"...\",\n            \"kid\": \"kid2\"\n        }\n    ]\n}\n</code></pre>"},{"location":"libraries/lib-lti1p3-core/doc/quickstart/jwks/#provide-a-jwks-response","title":"Provide a JWKS response","text":"<p>You can expose the JwksRequestHandler in an application controller to provide a ready to use JWKS PSR7 response for a given key set name:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Security\\Jwks\\Exporter\\JwksExporter;\nuse OAT\\Library\\Lti1p3Core\\Security\\Jwks\\Server\\JwksRequestHandler;\n\n$handler = new JwksRequestHandler(new JwksExporter($keyChainRepository));\n\n$response = $handler-&gt;handle('myKeySetName');\n</code></pre> <p>Note: Up to you to provide the logic to retrieve the key set name to expose.</p>"},{"location":"libraries/lib-lti1p3-core/doc/service/service-client/","title":"LTI service client","text":"<p>How to use the LtiServiceClient to perform authenticated LTI service calls as a tool.</p>"},{"location":"libraries/lib-lti1p3-core/doc/service/service-client/#features","title":"Features","text":"<p>You may need to perform authenticated service calls from your registered tool to a platform (ex: LTI Advantage Services)</p> <p>To do so, you can use the LtiServiceClient that permits:</p> <ul> <li>to call platform endpoints, returning a PSR7 response</li> <li>to perform automatically the required OAuth2 authentication to get an access token</li> <li>to handle automatically the access token caching if you provide an optional PSR6 cache instance</li> </ul>"},{"location":"libraries/lib-lti1p3-core/doc/service/service-client/#usage","title":"Usage","text":"<p>To use it, you can simply do by example:</p> <p><pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Service\\Client\\LtiServiceClient;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Cache\\CacheItemPoolInterface;\n\n// Get related registration of the launch\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Optional but HIGHLY RECOMMENDED cache for access tokens\n/** @var CacheItemPoolInterface $cache */\n$cache = ...\n\n$client = new LtiServiceClient($cache);\n\n/** @var ResponseInterface $response */\n$response = $client-&gt;request($registration, 'GET', 'https://platform.com/some-service-url', [...]);\n</code></pre> Note: the client decorates by default a guzzle client, but you can provide your own by implementing LtiServiceClientInterface</p>"},{"location":"libraries/lib-lti1p3-core/doc/service/service-server/","title":"LTI service server","text":"<p>How to set up an OAuth2 authorization server endpoint to protect your platforms LTI service endpoints.</p>"},{"location":"libraries/lib-lti1p3-core/doc/service/service-server/#preparation-of-required-dependencies","title":"Preparation of required dependencies","text":"<p>This library allow you to easily expose a OAuth2 server for a given subscription, to protect your LTI service calls as a platform.</p> <p>You can reuse this feature in several endpoints of your application to serve several servers for distinct registrations (client id).</p> <p>The server feature rely on the PHP League OAuth2 server, therefore you need to provide:</p> <ul> <li>a ClientRepositoryInterface implementation (to retrieve and validate your clients)</li> <li>a AccessTokenRepositoryInterface implementation (to store the created access tokens)</li> <li>a ScopeRepositoryInterface implementation (to retrieve your scopes)</li> </ul> <p>or you can simply use the available library repositories for this.</p> <p>Your will also need to provide an encryption key (random string with enough entropy).</p>"},{"location":"libraries/lib-lti1p3-core/doc/service/service-server/#generation-of-access-token-response-for-a-key-chain","title":"Generation of access token response for a key chain","text":"<p>This library provides a ready to use AccessTokenResponseGenerator to generate access tokens responses for a given key chain:</p> <ul> <li>it requires a key chain repository implementation as explained here to automate signature logic against a key chain private key</li> <li>it complies to the <code>client_credentials</code> grant type with <code>client_assertion</code> to follow IMS security specifications</li> <li>it expects a PSR7 ServerRequestInterface, a PSR7 ResponseInterface and a key chain identifier to be easily exposed behind any PSR7 compliant controller</li> </ul> <p>For example, to expose an LTI service server your application endpoint <code>[POST] /lti/auth/{keyChainIdentifier}/token</code>:</p> <pre><code>&lt;?php\n\nuse League\\OAuth2\\Server\\Exception\\OAuthServerException;\nuse OAT\\Library\\Lti1p3Core\\Security\\Key\\KeyChainRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Generator\\AccessTokenResponseGenerator;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Factory\\AuthorizationServerFactory;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Repository\\AccessTokenRepository;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Repository\\ClientRepository;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Repository\\ScopeRepository;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n$factory = new AuthorizationServerFactory(\n    new ClientRepository(...),\n    new AccessTokenRepository(...),\n    new ScopeRepository(...),\n    'superSecretEncryptionKey' // You obviously have to add more entropy, this is an example\n);\n\n/** @var KeyChainRepositoryInterface $repository */\n$repository = ...\n\n$generator = new AccessTokenResponseGenerator($repository, $factory);\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n/** @var ResponseInterface $response */\n$response = ...\n\ntry {\n    // Extract keyChainIdentifier from request uri parameter\n    $keyChainIdentifier = ...\n\n    // Validate assertion, generate and sign access token response, using the key chain private key\n    return $generator-&gt;generate($request, $response, $keyChainIdentifier);\n\n} catch (OAuthServerException $exception) {\n    return $exception-&gt;generateHttpResponse($response);\n}\n</code></pre>"},{"location":"libraries/lib-lti1p3-core/doc/service/service-server/#service-endpoint-authentication","title":"Service endpoint authentication","text":"<p>Once a tool has been granted with an access token, it can perform LTI service authenticated calls.</p> <p>(with header <code>Authorization: Bearer &lt;token&gt;</code>).</p> <p>To be able to protect your platform endpoints, you can use the provided RequestAccessTokenValidator:</p> <ul> <li>it requires a registration repository implementation as explained here to automate the token signature checks</li> <li>it expects a PSR7 ServerRequestInterface to validate</li> <li>it will output a RequestAccessTokenValidationResult representing the token validation, the related registration, the token itself and associated scopes.</li> </ul> <p>For example,</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Validator\\RequestAccessTokenValidator;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var RegistrationRepositoryInterface $repository */\n$repository = ...\n\n$validator = new RequestAccessTokenValidator($repository);\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n// Validate request provided access token using the registration platform public key, against allowed scopes\n$result = $validator-&gt;validate($request, ['allowed-scope', 'other-allowed-scope']);\n\n// Result exploitation\nif (!$result-&gt;hasError()) {\n    // You have access to related registration (to spare queries)\n    echo $result-&gt;getRegistration()-&gt;getIdentifier();\n\n    // And to the JWT\n    var_dump($result-&gt;getToken()-&gt;getHeaders()-&gt;all()); \n    var_dump($result-&gt;getToken()-&gt;getClaims()-&gt;all()); \n    echo ($result-&gt;getToken()-&gt;toString()); \n\n    // And to the oauth2 scopes\n    echo $result-&gt;getScopes();\n\n    // If needed, you can also access the validation successes\n    foreach ($result-&gt;getSuccesses() as $success) {\n        echo $success;\n    }\n}\n</code></pre>"},{"location":"libraries/lib-lti1p3-deep-linking/","title":"TAO - LTI 1.3 Deep Linking Library","text":"<p>IMS certified PHP library for LTI 1.3 Deep Linking implementations as platforms and / or as tools, based on LTI 1.3 Core library.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/#ims","title":"IMS","text":"<p>You can find below IMS related information.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/#related-certifications","title":"Related certifications","text":"<ul> <li>LTI 1.3 advantage complete</li> </ul>"},{"location":"libraries/lib-lti1p3-deep-linking/#related-specifications","title":"Related specifications","text":"<ul> <li>IMS LTI 1.3 Deep Linking</li> <li>IMS LTI 1.3 Core</li> <li>IMS Security</li> </ul>"},{"location":"libraries/lib-lti1p3-deep-linking/#installation","title":"Installation","text":"<pre><code>$ composer require oat-sa/lib-lti1p3-deep-linking\n</code></pre>"},{"location":"libraries/lib-lti1p3-deep-linking/#documentation","title":"Documentation","text":"<p>You can find below the library documentation, presented by topics.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/#configuration","title":"Configuration","text":"<ul> <li>how to configure the underlying LTI 1.3 Core library</li> </ul>"},{"location":"libraries/lib-lti1p3-deep-linking/#workflow","title":"Workflow","text":"<ul> <li>how to implement the deep linking workflow (as platform and / or tool)</li> </ul>"},{"location":"libraries/lib-lti1p3-deep-linking/#tests","title":"Tests","text":"<p>To run tests:</p> <p><pre><code>$ vendor/bin/phpunit\n</code></pre> Note: see phpunit.xml.dist for available test suites.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/","title":"Deep Linking Workflow","text":"<p>How to perform secured Deep Linking interactions, between platforms and tools.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#workflow","title":"Workflow","text":"<p>You can find below a Deep Linking workflow diagram, with steps numbers:</p> <p></p> <p>Each step will be detailed below, from both platform and tool perspectives.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#1-platform-side-deep-linking-request-generation","title":"1 - Platform side: deep linking request generation","text":"<p>You can find below required steps to generate a deep linking request message, needed only if you're acting as a platform.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#create-the-message","title":"Create the message","text":"<p>As a platform, you can create a deep linking request message for a tool within the context of a registration.</p> <p>Platforms can drive the tool behaviour on deep linking interactions by providing deep linking settings.</p> <p>You have to first provide a DeepLinkingSettingsInterface implementation to configure your settings:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Resource\\Link\\LinkInterface;\nuse OAT\\Library\\Lti1p3Core\\Resource\\LtiResourceLink\\LtiResourceLinkInterface;\nuse OAT\\Library\\Lti1p3DeepLinking\\Settings\\DeepLinkingSettings;\n\n// Create deep linking settings\n$deepLinkingSettings = new DeepLinkingSettings(\n    'http://platform.com/deep-linking-return',  // [required] platform url where to return content items\n    [\n        LinkInterface::TYPE,                    // [required] array of accepted content items types \n        LtiResourceLinkInterface::TYPE,\n    ],\n    [                                           // [required] array of accepted presentation document targets\n        'window',\n        'iframe'\n    ],\n    'image/*,text/html',                        // [optional] list of accepted media types, comma separated\n    true,                                       // [optional] if should accept multiple content items (default true)\n    false,                                      // [optional] if should auto create content items tool side (default false)\n    'Title',                                    // [optional] title\n    'Description'                               // [optional] description\n);\n</code></pre> <p>Then, you can use the DeepLinkingLaunchRequestBuilder to create the message:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3DeepLinking\\Message\\Launch\\Builder\\DeepLinkingLaunchRequestBuilder;\n\n// Create a builder instance\n$builder = new DeepLinkingLaunchRequestBuilder();\n\n// Get related registration of the launch\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Build a deep linking request launch message\n$message = $builder-&gt;buildDeepLinkingLaunchRequest(\n    $deepLinkingSettings,                                          // [required] deep linking settings\n    $registration,                                                 // [required] related registration\n    'loginHint',                                                   // [required] login hint that will be used afterwards by the platform to perform authentication\n    'http://platform.com/deep-linking-return',                     // [optional] will launch to provided url, or fallback to tool's default deep linking url if null\n    null,                                                          // [optional] will use the registration default deployment id, but you can pass a specific one\n    ['http://purl.imsglobal.org/vocab/lis/v2/membership#Learner'], // [optional] roles\n    ['myCustomClaim' =&gt; 'myCustomValue']                           // [optional] supplementary claims if needed\n);\n</code></pre>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#launch-the-message","title":"Launch the message","text":"<p>As a result of the build, you get a LtiMessageInterface instance that has to be used in the following ways:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\LtiMessageInterface;\n\n/** @var LtiMessageInterface $message */\n\n// Main message properties you can use as you want to offer the launch to the platform users\necho $message-&gt;getUrl();                // url of the launch\necho $message-&gt;getParameters()-&gt;all();  // array of parameters of the launch\n\n// Or use those helpers methods to ease the launch interactions\necho $message-&gt;toUrl();                // url with launch parameters as query parameters\necho $message-&gt;toHtmlLink('click me'); // HTML link, where href is the output url\necho $message-&gt;toHtmlRedirectForm();   // HTML hidden form, with possibility of auto redirection\n</code></pre>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#implement-openid-connect-launch-flow","title":"Implement OpenId Connect launch flow","text":"<p>Like any platform originating message, when the deep linking request message is launched, an OIDC flow will start between the tool and the platform.</p> <p>The underlying core library offers everything you need to securely implement this flow, as documented in the platform originating messages documentation.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#2-tool-side-deep-linking-request-handling","title":"2 - Tool side: deep linking request handling","text":"<p>You can find below required steps to handle a deep linking launch request, needed only if you're acting as a tool.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#validate-the-request","title":"Validate the request","text":"<p>As a tool, you'll receive an HTTP request containing the Deep Linking request message, generated by the platform, received after OIDC flow completion.</p> <p>You can use the ToolLaunchValidator to validate it:</p> <p><pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\Tool\\ToolLaunchValidator;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Nonce\\NonceRepositoryInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var NonceRepositoryInterface $nonceRepository */\n$nonceRepository = ...\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n// Create the validator\n$validator = new ToolLaunchValidator($registrationRepository, $nonceRepository);\n\n// Perform validation\n$result = $validator-&gt;validatePlatformOriginatingLaunch($request);\n\nif (!$result-&gt;hasError()) {\n    // Your logic to handle the deep linking request and offer content items selection\n}\n</code></pre> Note: more details about platform originating messages on tool side validation can be found in the platform originating messages documentation.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#offer-content-items-selection","title":"Offer content items selection","text":"<p>When a deep linking request is received by a tool, the tool may offer the user content items selection according to the platform deep linking settings.</p> <p>For example:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\Result\\LaunchValidationResultInterface;\n\n/** @var LaunchValidationResultInterface $result */\n$result = $validator-&gt;validatePlatformOriginatingLaunch($request);\n\nif (!$result-&gt;hasError()) {\n    // You have access to platform deep linking settings claim\n    $settings = $result-&gt;getPayload()-&gt;getDeepLinkingSettings();\n\n    // You can extract from it the information to build and offer relevant content items selection \n    var_dump($settings-&gt;getDeepLinkingReturnUrl());                // 'http://platform.com/deep-linking-return'\n    var_dump($settings-&gt;getAcceptedTypes());                       // ['link', 'ltiResourceLink']\n    var_dump($settings-&gt;getAcceptedPresentationDocumentTargets()); // ['window', 'iframe']\n    ...\n} \n</code></pre> <p>From here, up to you to decide if / how you offer content items selection: you can offer the user an <code>HTML Form</code> for example.</p> <p>Since this process can differ a lot between tool applications, this library does not provide any tooling for this (to leave you free to provide your own process). </p> <p>The library will take care of the rest of the process, when the tool will return the selected content items to the platform.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#3-tool-side-deep-linking-response-generation","title":"3 - Tool side: deep linking response generation","text":"<p>You can find below required steps to provide a deep linking response to return the content items selection, needed only if you're acting as a tool.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#collect-the-content-items-to-be-returned","title":"Collect the content items to be returned","text":"<p>Depending on if / how you offered content items selection tool side, you can afterwards aggregate selected resources in a ResourceCollectionInterface implementation:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Resource\\Link\\Link;\nuse OAT\\Library\\Lti1p3Core\\Resource\\LtiResourceLink\\LtiResourceLink;\nuse OAT\\Library\\Lti1p3Core\\Resource\\ResourceCollection;\n\n// Get selected content items (resources)\n$link = new Link('linkIdentifier', 'http://tool.com/some-link');\n$ltiResourceLink = new LtiResourceLink('ltiResourceLinkIdentifier', ['url' =&gt; 'http://tool.com/launch']);\n\n// Aggregate them in a collection\n$resourceCollection = new ResourceCollection();\n$resourceCollection\n    -&gt;add($link)\n    -&gt;add($ltiResourceLink);\n</code></pre>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#create-the-message_1","title":"Create the message","text":"<p>Once the resource collection ready, you can return it to the platform in a deep linking response message, by using the DeepLinkingLaunchResponseBuilder:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\Result\\LaunchValidationResultInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3DeepLinking\\Message\\Launch\\Builder\\DeepLinkingLaunchResponseBuilder;\n\n/** @var LaunchValidationResultInterface $result */\n$result = $validator-&gt;validatePlatformOriginatingLaunch(...);\n\n// Create a builder instance\n$builder = new DeepLinkingLaunchResponseBuilder();\n\n// Related deep linking platform settings claim from previous steps\n$deepLinkingSettingsClaim = $result-&gt;getPayload()-&gt;getDeepLinkingSettings();\n\n// Get related registration of the launch\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Build a deep linking response launch message\n$message = $builder-&gt;buildDeepLinkingLaunchResponse(\n    $resourceCollection,                                   // [required] content items collection\n    $registration,                                         // [required] related registration\n    $deepLinkingSettingsClaim-&gt;getDeepLinkingReturnUrl(),  // [required] platform url whereto return content items\n    null,                                                  // [optional] will use the registration default deployment id, but you can pass a specific one\n    $deepLinkingSettingsClaim-&gt;getData(),                  // [optional] platform settings data, must be returned unaltered if provided\n    '2 content items provided with success'                // [optional] to override the default feedback message\n);\n</code></pre>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#launch-the-message_1","title":"Launch the message","text":"<p>As a result of the build, you get a LtiMessageInterface instance that has to be sent as a form POST:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\LtiMessageInterface;\n\n/** @var LtiMessageInterface $message */\necho $message-&gt;toHtmlRedirectForm(); // HTML form containing the auto generated JWT parameter\n</code></pre>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#4-platform-side-deep-linking-response-handling","title":"4 - Platform side: deep linking response handling","text":"<p>You can find below required steps to validate a deep linking response, needed only if you're acting as a platform.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#validate-the-response","title":"Validate the response","text":"<p>As a platform, you'll receive an HTTP request containing the deep linking response message.</p> <p>The PlatformLaunchValidator can be used for this:</p> <ul> <li>it requires a registration repository and a nonce repository implementations as explained here</li> <li>it expects a PSR7 ServerRequestInterface to validate</li> <li>it will output a LaunchValidationResult representing the launch validation, the related registration and the deep linking response payload itself.</li> </ul> <p><pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\Platform\\PlatformLaunchValidator;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Nonce\\NonceRepositoryInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var NonceRepositoryInterface $nonceRepository */\n$nonceRepository = ...\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n// Create the validator\n$validator = new PlatformLaunchValidator($registrationRepository, $nonceRepository);\n\n// Perform validation\n$result = $validator-&gt;validateToolOriginatingLaunch($request);\n\nif (!$result-&gt;hasError()) {\n    // Your logic to handle the returned content items\n}\n</code></pre> Note: more details about tool originating messages on platform side validation can be found in the tool originating messages documentation.</p>"},{"location":"libraries/lib-lti1p3-deep-linking/doc/deep-linking-workflow/#handle-the-returned-content-items","title":"Handle the returned content items","text":"<p>Once the deep linking response validation done, you can access the returned content items from the response payload:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\Result\\LaunchValidationResultInterface;\nuse OAT\\Library\\Lti1p3Core\\Resource\\Link\\LinkInterface;\nuse OAT\\Library\\Lti1p3Core\\Resource\\LtiResourceLink\\LtiResourceLinkInterface;\nuse OAT\\Library\\Lti1p3DeepLinking\\Factory\\ResourceCollectionFactory;\n\n/** @var LaunchValidationResultInterface $result */\n$result = $validator-&gt;validateToolOriginatingLaunch($request);\n\nif (!$result-&gt;hasError()) {\n    // You have access to tool deep linking content items claim\n    $contentItems = $result-&gt;getPayload()-&gt;getDeepLinkingContentItems();\n\n    // You can use the ResourceCollectionFactory to ease the resources extraction as collection\n    $returnedResourceCollection = (new ResourceCollectionFactory())-&gt;createFromClaim($contentItems);\n\n    // Then perform your resources manipulations, for example:\n    $returnedLink = current($returnedResourceCollection-&gt;getByType(LinkInterface::TYPE));\n    echo $returnedLink-&gt;getIdentifier(); // 'linkIdentifier'\n    echo $returnedLink-&gt;getUrl();        // 'http://tool.com/some-link'\n\n    $returnedLtiResourceLinkLink = current($returnedResourceCollection-&gt;getByType(LtiResourceLinkInterface::TYPE));\n    echo $returnedLtiResourceLinkLink-&gt;getIdentifier(); // 'ltiResourceLinkIdentifier'\n    echo $returnedLtiResourceLinkLink-&gt;getUrl();        // 'http://tool.com/launch'\n    ...\n} \n</code></pre> <p>Note: if an LtiResourceLink instance is returned, you can easily create a launch from it by following the platform originating messages documentation.</p>"},{"location":"libraries/lib-lti1p3-nrps/","title":"TAO - LTI 1.3 NRPS Library","text":"<p>IMS certified PHP library for LTI 1.3 Names and Role Provisioning Services implementations as platforms and / or as tools, based on LTI 1.3 Core library.</p>"},{"location":"libraries/lib-lti1p3-nrps/#ims","title":"IMS","text":"<p>You can find below IMS related information.</p>"},{"location":"libraries/lib-lti1p3-nrps/#related-certifications","title":"Related certifications","text":"<ul> <li>LTI 1.3 advantage complete</li> </ul>"},{"location":"libraries/lib-lti1p3-nrps/#related-specifications","title":"Related specifications","text":"<ul> <li>IMS LTI 1.3 Names and Role Provisioning Services</li> <li>IMS LTI 1.3 Core</li> <li>IMS Security</li> </ul>"},{"location":"libraries/lib-lti1p3-nrps/#installation","title":"Installation","text":"<pre><code>$ composer require oat-sa/lib-lti1p3-nrps\n</code></pre>"},{"location":"libraries/lib-lti1p3-nrps/#documentation","title":"Documentation","text":"<p>You can find below the library documentation, presented by topics.</p>"},{"location":"libraries/lib-lti1p3-nrps/#configuration","title":"Configuration","text":"<ul> <li>how to configure the underlying LTI 1.3 Core library</li> </ul>"},{"location":"libraries/lib-lti1p3-nrps/#platform","title":"Platform","text":"<ul> <li>how to use the NRPS library as a platform</li> </ul>"},{"location":"libraries/lib-lti1p3-nrps/#tool","title":"Tool","text":"<ul> <li>how to use the NRPS library as a tool</li> </ul>"},{"location":"libraries/lib-lti1p3-nrps/#tests","title":"Tests","text":"<p>To run tests:</p> <p><pre><code>$ vendor/bin/phpunit\n</code></pre> Note: see phpunit.xml.dist for available test suites.</p>"},{"location":"libraries/lib-lti1p3-nrps/doc/platform/","title":"NRPS Platform - Membership service server","text":"<p>How to use the MembershipServiceServerRequestHandler (with the core LtiServiceServer) to serve authenticated NRPS service calls as a platform.</p>"},{"location":"libraries/lib-lti1p3-nrps/doc/platform/#features","title":"Features","text":"<p>This library provides a MembershipServiceServerRequestHandler ready to be use with the core LtiServiceServer to handle context and resource link membership requests.</p> <ul> <li>it accepts a PSR7 ServerRequestInterface,</li> <li>leverages the required IMS LTI 1.3 service authentication,</li> <li>and returns a PSR7 ResponseInterface containing the <code>membership</code> representation</li> </ul>"},{"location":"libraries/lib-lti1p3-nrps/doc/platform/#usage","title":"Usage","text":"<p>First, you need to provide a MembershipServiceServerBuilderInterface implementation, in charge to build memberships on tools context or resource link requests.</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationInterface;\nuse OAT\\Library\\Lti1p3Nrps\\Model\\Membership\\MembershipInterface;\nuse OAT\\Library\\Lti1p3Nrps\\Service\\Server\\Builder\\MembershipServiceServerBuilderInterface;\n\n/** @var MembershipServiceServerBuilderInterface $builder */\n$builder = new class() implements MembershipServiceServerBuilderInterface \n{\n    public function buildContextMembership(\n        RegistrationInterface $registration,\n        ?string $role = null,\n        ?int $limit = null,\n        ?int $offset = null\n    ): MembershipInterface {\n        // Logic for building context membership for a given registration\n    }\n\n    public function buildResourceLinkMembership(\n        RegistrationInterface $registration,\n        string $resourceLinkIdentifier,\n        ?string $role = null,\n        ?int $limit = null,\n        ?int $offset = null\n    ): MembershipInterface {\n        // Logic for building resource link membership for a given registration and resource link identifier\n    }\n};\n</code></pre> <p>Then:</p> <ul> <li>you can construct the MembershipServiceServerRequestHandler (constructed with your MembershipServiceServerBuilderInterface implementation)</li> <li>to finally expose it to requests using the core LtiServiceServer (constructed with the RequestAccessTokenValidator, from core library)</li> </ul> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Validator\\RequestAccessTokenValidator;\nuse OAT\\Library\\Lti1p3Core\\Service\\Server\\LtiServiceServer;\nuse OAT\\Library\\Lti1p3Nrps\\Service\\Server\\Builder\\MembershipServiceServerBuilderInterface;\nuse OAT\\Library\\Lti1p3Nrps\\Service\\Server\\Handler\\MembershipServiceServerRequestHandler;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n/** @var RegistrationRepositoryInterface $repository */\n$repository = ...\n\n/** @var MembershipServiceServerBuilderInterface $builder */\n$builder = ...\n\n$validator = new RequestAccessTokenValidator($repository);\n\n$handler = new MembershipServiceServerRequestHandler($builder);\n\n$server = new LtiServiceServer($validator, $handler);\n\n// Generates an authenticated response containing the built membership representation\n$response = $server-&gt;handle($request);\n</code></pre>"},{"location":"libraries/lib-lti1p3-nrps/doc/tool/","title":"NRPS Tool - Membership service client","text":"<p>How to use the MembershipServiceClient to perform authenticated NRPS service calls as a tool.</p>"},{"location":"libraries/lib-lti1p3-nrps/doc/tool/#features","title":"Features","text":"<p>This library provides a MembershipServiceClient (based on the core LtiServiceClient) that allow retrieving NRPS memberships exposed by a platform.</p>"},{"location":"libraries/lib-lti1p3-nrps/doc/tool/#usage","title":"Usage","text":""},{"location":"libraries/lib-lti1p3-nrps/doc/tool/#get-a-context-membership","title":"Get a context membership","text":"<pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Payload\\LtiMessagePayloadInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Nrps\\Service\\Client\\MembershipServiceClient;\n\n// Related registration\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Related LTI 1.3 message payload\n/** @var LtiMessagePayloadInterface $payload */\n$payload  = ...;\n\n$membershipServiceClient = new MembershipServiceClient();\n\n$membership = $membershipServiceClient-&gt;getContextMembershipForPayload(\n    $registration, // [required] as the tool, it will call the platform of this registration\n    $payload,      // [required] for the LTI message payload containing the NRPS claim (got at LTI launch)\n    'Learner',     // [optional] we can filter members for a role (default: no filter)\n    10             // [optional] and limit the number of presented members (default: no limit)\n);\n\n// you also can call directly for a received NRPS claim\n$membership = $membershipServiceClient-&gt;getContextMembershipForClaim(\n    $registration,       // [required] as the tool, it will call the platform of this registration\n    $payload-&gt;getNrps(), // [required] for a NRPS claim (got at LTI launch)\n    'Learner',           // [optional] we can filter members for a role (default: no filter)\n    10                   // [optional] and limit the number of presented members (default: no limit)\n);\n\n// or you also can call directly for an given URL (avoid claim construction)\n$membership = $membershipServiceClient-&gt;getContextMembership(\n    $registration,                     // [required] as the tool, it will call the platform of this registration\n    'https://example.com/memberships', // [required] to a given membership service url\n    'Learner',                         // [optional] we can filter members for a role (default: no filter)\n    10                                 // [optional] and limit the number of presented members (default: no limit)\n);\n\n// Membership identifier\necho $membership-&gt;getIdentifier();\n\n// Membership context\necho $membership-&gt;getContext()-&gt;getIdentifier();\n\n// Membership members\nforeach ($membership-&gt;getMembers() as $member) {\n    echo $member-&gt;getUserIdentity()-&gt;getIdentifier();\n}\n\n// Membership analysed relation link (to know presence of next or differences)\necho $membership-&gt;getRelationLinkUrl();\n\nif ($membership-&gt;hasNext()) {\n    // handle retrieval of the next members\n}\n\nif ($membership-&gt;hasDifferences()) {\n    // handle differences of the members\n}\n</code></pre>"},{"location":"libraries/lib-lti1p3-nrps/doc/tool/#get-a-resource-link-membership","title":"Get a resource link membership","text":"<pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Payload\\LtiMessagePayloadInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Nrps\\Service\\Client\\MembershipServiceClient;\n\n// Related registration\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Related LTI 1.3 message payload\n/** @var LtiMessagePayloadInterface $payload */\n$payload  = ...;\n\n$membershipServiceClient = new MembershipServiceClient();\n\n$membership = $membershipServiceClient-&gt;getResourceLinkMembershipForPayload(\n    $registration, // [required] as the tool, it will call the platform of this registration\n    $payload,      // [required] for the LTI message payload containing the NRPS and ResourceLink claims (got at LTI launch)\n    'Learner',     // [optional] we can filter members for a role (default: no filter)\n    10             // [optional] and limit the number of presented members (default: no limit)\n);\n\n// you also can call directly for a received NRPS claim\n$membership = $membershipServiceClient-&gt;getResourceLinkMembershipForClaim(\n    $registration,       // [required] as the tool, it will call the platform of this registration\n    $payload-&gt;getNrps(), // [required] for a NRPS claim (got at LTI launch)\n    'someIdentifier',    // [required] for a resource link identifier\n    'Learner',           // [optional] we can filter members for a role (default: no filter)\n    10                   // [optional] and limit the number of presented members (default: no limit)\n);\n\n// or you also can call directly for an given URL and resource link identifier (avoid claims construction)\n$membership = $membershipServiceClient-&gt;getResourceLinkMembership(\n    $registration,                     // [required] as the tool, it will call the platform of this registration\n    'https://example.com/memberships', // [required] to a given membership service url\n    'someIdentifier',                  // [required] for a given resource link identifier\n    'Learner',                         // [optional] we can filter members for a role (default: no filter)\n    10                                 // [optional] and limit the number of presented members (default: no limit)\n);\n\n// ...\n</code></pre>"},{"location":"libraries/lib-lti1p3-proctoring/","title":"TAO - LTI 1.3 Proctoring Library","text":"<p>IMS certified PHP library for LTI 1.3 Proctoring implementations as platforms and / or as tools, based on LTI 1.3 Core library.</p>"},{"location":"libraries/lib-lti1p3-proctoring/#ims","title":"IMS","text":"<p>You can find below IMS related information.</p>"},{"location":"libraries/lib-lti1p3-proctoring/#related-certifications","title":"Related certifications","text":"<ul> <li>LTI 1.3 proctoring services</li> </ul>"},{"location":"libraries/lib-lti1p3-proctoring/#related-specifications","title":"Related specifications","text":"<ul> <li>IMS LTI 1.3 Proctoring</li> <li>IMS LTI 1.3 Core</li> <li>IMS Security</li> </ul>"},{"location":"libraries/lib-lti1p3-proctoring/#installation","title":"Installation","text":"<pre><code>$ composer require oat-sa/lib-lti1p3-proctoring\n</code></pre>"},{"location":"libraries/lib-lti1p3-proctoring/#documentation","title":"Documentation","text":"<p>You can find below the library documentation, presented by topics.</p>"},{"location":"libraries/lib-lti1p3-proctoring/#configuration","title":"Configuration","text":"<ul> <li>how to configure the underlying LTI 1.3 Core library</li> </ul>"},{"location":"libraries/lib-lti1p3-proctoring/#messages","title":"Messages","text":"<ul> <li>how to implement the proctoring messages workflow (as platform and / or tool)</li> </ul>"},{"location":"libraries/lib-lti1p3-proctoring/#services","title":"Services","text":"<ul> <li>how to use the library for ACS as a platform</li> <li>how to use the library for ACS as a tool</li> </ul>"},{"location":"libraries/lib-lti1p3-proctoring/#tests","title":"Tests","text":"<p>To run tests:</p> <p><pre><code>$ vendor/bin/phpunit\n</code></pre> Note: see phpunit.xml.dist for available test suites.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/","title":"Proctoring Messages Workflow","text":"<p>How to perform secured proctoring message interactions, between platforms and tools.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#workflow","title":"Workflow","text":"<p>You can find below a proctoring messages workflow diagram, with steps numbers:</p> <p></p> <p>Each step will be detailed below, from both platform and tool perspectives.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#1-platform-side-startproctoring-message-generation","title":"1 - Platform side: StartProctoring message generation","text":"<p>You can find below required steps to generate a StartProctoring message, needed only if you're acting as a platform.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#create-the-message","title":"Create the message","text":"<p>As a platform, you can create a StartProctoring message for a tool within the context of a registration.</p> <p>Platforms can drive the tool behaviour on proctoring interactions by providing claims in this message.</p> <p>You can use the StartProctoringLaunchRequestBuilder to create the message:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Resource\\LtiResourceLink\\LtiResourceLink;\nuse OAT\\Library\\Lti1p3Proctoring\\Message\\Launch\\Builder\\StartProctoringLaunchRequestBuilder;\n\n// Create a resource link\n$resourceLink = new LtiResourceLink('resourceLinkIdentifier');\n\n// Create a builder instance\n$builder = new StartProctoringLaunchRequestBuilder();\n\n// Get related registration of the launch\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Build StartProctoring message\n$message = $builder-&gt;buildStartProctoringLaunchRequest(\n    $resourceLink,                                                 // [required] resource link\n    $registration,                                                 // [required] related registration\n    'http://platform.com/start-assessment',                        // [required] platform url where to send later the StartAssessment message\n    'loginHint',                                                   // [required] login hint that will be used afterwards by the platform to perform authentication\n    1,                                                             // [optional] attempt number (default 1)\n    null,                                                          // [optional] will use the registration default deployment id, but you can pass a specific one\n    ['http://purl.imsglobal.org/vocab/lis/v2/membership#Learner'], // [optional] roles\n    ['myCustomClaim' =&gt; 'myCustomValue']                           // [optional] supplementary claims if needed\n);\n</code></pre>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#launch-the-message","title":"Launch the message","text":"<p>As a result of the build, you get a LtiMessageInterface instance that has to be used in the following ways:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\LtiMessageInterface;\n\n/** @var LtiMessageInterface $message */\n\n// Main message properties you can use as you want to offer the launch to the platform users\necho $message-&gt;getUrl();                // url of the launch\necho $message-&gt;getParameters()-&gt;all();  // array of parameters of the launch\n\n// Or use those helpers methods to ease the launch interactions\necho $message-&gt;toUrl();                // url with launch parameters as query parameters\necho $message-&gt;toHtmlLink('click me'); // HTML link, where href is the output url\necho $message-&gt;toHtmlRedirectForm();   // HTML hidden form, with possibility of auto redirection\n</code></pre>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#implement-openid-connect-launch-flow","title":"Implement OpenId Connect launch flow","text":"<p>Like any platform originating message, when the StartProctoring message is launched, an OIDC flow will start between the tool and the platform.</p> <p>The underlying core library offers everything you need to securely implement this flow, as documented in the platform originating messages documentation.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#2-tool-side-startproctoring-message-handling","title":"2 - Tool side: StartProctoring message handling","text":"<p>You can find below required steps to handle a StartProctoring message, needed only if you're acting as a tool.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#validate-the-message","title":"Validate the message","text":"<p>As a tool, you'll receive an HTTP request containing the StartProctoring message, generated by the platform, received after OIDC flow completion.</p> <p>You can use the ToolLaunchValidator to validate it:</p> <p><pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\Tool\\ToolLaunchValidator;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Nonce\\NonceRepositoryInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var NonceRepositoryInterface $nonceRepository */\n$nonceRepository = ...\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n// Create the validator\n$validator = new ToolLaunchValidator($registrationRepository, $nonceRepository);\n\n// Perform validation\n$result = $validator-&gt;validatePlatformOriginatingLaunch($request);\n\nif (!$result-&gt;hasError()) {\n    // Your logic to handle the StartProctoring message and offer proctor candidate attempt validation\n}\n</code></pre> Note: more details about platform originating messages on tool side validation can be found in the platform originating messages documentation.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#offer-proctor-validation","title":"Offer proctor validation","text":"<p>When a StartProctoring message is received by a tool, the tool may offer various ways to the proctor to validate candidate attempt (webcam, etc).</p> <p>Since this process can differ a lot between proctoring tool applications, this library does not provide any tooling for this (to leave you free to provide your own process or to delegate to external ones). </p> <p>The library will take care of the rest of the process, when the tool will redirect the candidate to the platform.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#3-tool-side-startassessment-message-generation","title":"3 - Tool side: StartAssessment message generation","text":"<p>You can find below required steps to generate a StartAssessment message to return to the platform, needed only if you're acting as a tool.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#create-the-message_1","title":"Create the message","text":"<p>Once the proctor's candidate attempt validation is done, you can return to the platform using a StartAssessment message, by using the StartAssessmentLaunchRequestBuilder:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\Result\\LaunchValidationResultInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Proctoring\\Message\\Launch\\Builder\\StartAssessmentLaunchRequestBuilder;\n\n/** @var LaunchValidationResultInterface $result */\n$result = $validator-&gt;validatePlatformOriginatingLaunch(...);\n\n// Create a builder instance\n$builder = new StartAssessmentLaunchRequestBuilder();\n\n// Message payload from previous StartProctoring message step\n$payload = $result-&gt;getPayload();\n\n// Get related registration of the launch\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Build a StartAssessment message\n$message = $builder-&gt;buildStartAssessmentLaunchRequest(\n    $payload-&gt;getResourceLink(),                           // [required] resource link as provided in StartProctoring message\n    $registration,                                         // [required] related registration\n    $payload-&gt;getProctoringStartAssessmentUrl(),           // [required] platform StartAssessment url as provided in StartProctoring message\n    $payload-&gt;getProctoringSessionData(),                  // [required] session data as provided in StartProctoring message\n    $payload-&gt;getProctoringAttemptNumber(),                // [required] attempt number as provided in StartProctoring message\n    null,                                                  // [optional] will use the registration default deployment id, but you can pass a specific one\n    ['myCustomClaim' =&gt; 'myCustomValue']                   // [optional] supplementary claims if needed\n);\n</code></pre> <p>Note: to ease a bit this step, you can also use the <code>buildStartAssessmentLaunchRequestFromPayload()</code> method to work directly with the previous StartProctoring message payload if you still can access it:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\Result\\LaunchValidationResultInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Proctoring\\Message\\Launch\\Builder\\StartAssessmentLaunchRequestBuilder;\n\n/** @var LaunchValidationResultInterface $result */\n$result = $validator-&gt;validatePlatformOriginatingLaunch(...);\n\n// Create a builder instance\n$builder = new StartAssessmentLaunchRequestBuilder();\n\n// Message payload from previous StartProctoring message step\n$payload = $result-&gt;getPayload();\n\n// Get related registration of the launch\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Build a StartAssessment message\n$message = $builder-&gt;buildStartAssessmentLaunchRequestFromPayload(\n    $payload,                                  // [required] provided in StartProctoring message payload\n    $registration,                             // [required] related registration\n    null,                                      // [optional] will use the registration default deployment id, but you can pass a specific one\n    ['myCustomClaim' =&gt; 'myCustomValue']       // [optional] supplementary claims if needed\n);\n</code></pre>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#launch-the-message_1","title":"Launch the message","text":"<p>As a result of the build, you get a LtiMessageInterface instance that has to be sent as a form POST:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\LtiMessageInterface;\n\n/** @var LtiMessageInterface $message */\necho $message-&gt;toHtmlRedirectForm(); // HTML form containing the auto generated JWT parameter\n</code></pre>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#4-platform-side-startassessment-message-handling","title":"4 - Platform side: StartAssessment message handling","text":"<p>You can find below required steps to validate a StartAssessment message, needed only if you're acting as a platform.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#validate-the-message_1","title":"Validate the message","text":"<p>As a platform, you'll receive an HTTP request containing the StartAssessment message.</p> <p>The PlatformLaunchValidator can be used for this:</p> <ul> <li>it requires a registration repository and a nonce repository implementations as explained here</li> <li>it expects a PSR7 ServerRequestInterface to validate</li> <li>it will output a LaunchValidationResult representing the launch validation, the related registration and the StartAssessment payload itself.</li> </ul> <p><pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\Platform\\PlatformLaunchValidator;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Nonce\\NonceRepositoryInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var NonceRepositoryInterface $nonceRepository */\n$nonceRepository = ...\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n// Create the validator\n$validator = new PlatformLaunchValidator($registrationRepository, $nonceRepository);\n\n// Perform validation\n$result = $validator-&gt;validateToolOriginatingLaunch($request);\n\nif (!$result-&gt;hasError()) {\n    // Your logic to handle the StartAssessment message: start the candidate attempt for example\n}\n</code></pre> Note: more details about tool originating messages on platform side validation can be found in the tool originating messages documentation.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#5-platform-side-endassessment-message-generation","title":"5 - Platform side: EndAssessment message generation","text":"<p>You can find below required steps to generate an EndAssessment message, needed only if you're acting as a platform and if the tool indicated the need to send this message.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#create-the-message_2","title":"Create the message","text":"<p>As a platform, you can create a EndAssessment message for a tool within the context of a registration.</p> <p>Platforms can drive the tool behaviour on proctoring interactions by providing claims in this message.</p> <p>You can use the EndAssessmentLaunchRequestBuilder to create the message:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Proctoring\\Message\\Launch\\Builder\\EndAssessmentLaunchRequestBuilder;\n\n// Create a builder instance\n$builder = new EndAssessmentLaunchRequestBuilder();\n\n// Get related registration of the launch\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Build EndAssessment message\n$message = $builder-&gt;buildEndAssessmentLaunchRequest(\n    $registration,                                                 // [required] related registration\n    'loginHint',                                                   // [required] login hint that will be used afterwards by the platform to perform authentication\n    'http://tool.com/end-assessment',                              // [optional] tool url where to send the EndAssessment message (will use tool default launch url if not provided)\n    1,                                                             // [optional] attempt number (default 1)\n    null,                                                          // [optional] will use the registration default deployment id, but you can pass a specific one\n    ['http://purl.imsglobal.org/vocab/lis/v2/membership#Learner'], // [optional] roles\n    ['myCustomClaim' =&gt; 'myCustomValue']                           // [optional] supplementary claims if needed\n);\n</code></pre> <p>Note: you can also use the <code>buildEndAssessmentLaunchErrorRequest()</code> method if you want to notify the tool in an easy way that an error occurred platform side.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#launch-the-message_2","title":"Launch the message","text":"<p>As a result of the build, you get a LtiMessageInterface instance that has to be used in the following ways:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\LtiMessageInterface;\n\n/** @var LtiMessageInterface $message */\n\n// Main message properties you can use as you want to offer the launch to the platform users\necho $message-&gt;getUrl();                // url of the launch\necho $message-&gt;getParameters()-&gt;all();  // array of parameters of the launch\n\n// Or use those helpers methods to ease the launch interactions\necho $message-&gt;toUrl();                // url with launch parameters as query parameters\necho $message-&gt;toHtmlLink('click me'); // HTML link, where href is the output url\necho $message-&gt;toHtmlRedirectForm();   // HTML hidden form, with possibility of auto redirection\n</code></pre>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#implement-openid-connect-launch-flow_1","title":"Implement OpenId Connect launch flow","text":"<p>Like any platform originating message, when the EndAssessment message is launched, an OIDC flow will start between the tool and the platform.</p> <p>The underlying core library offers everything you need to securely implement this flow, as documented in the platform originating messages documentation.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#6-tool-side-endassessment-message-handling","title":"6 - Tool side: EndAssessment message handling","text":"<p>You can find below required steps to handle a EndAssessment message, needed only if you're acting as a tool.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/message/proctoring-workflow/#validate-the-message_2","title":"Validate the message","text":"<p>As a tool, you'll receive an HTTP request containing the EndAssessment message, generated by the platform, received after OIDC flow completion.</p> <p>You can use the ToolLaunchValidator to validate it:</p> <p><pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\Tool\\ToolLaunchValidator;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Nonce\\NonceRepositoryInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var NonceRepositoryInterface $nonceRepository */\n$nonceRepository = ...\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n// Create the validator\n$validator = new ToolLaunchValidator($registrationRepository, $nonceRepository);\n\n// Perform validation\n$result = $validator-&gt;validatePlatformOriginatingLaunch($request);\n\nif (!$result-&gt;hasError()) {\n    // Your logic to handle the EndAssessment message\n}\n</code></pre> Note: more details about platform originating messages on tool side validation can be found in the platform originating messages documentation.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/service/platform/","title":"ACS Platform - Assessment Control Service server","text":"<p>How to use the AcsServiceServerRequestHandler (with the core LtiServiceServer) to serve authenticated ACS service calls as a platform.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/service/platform/#features","title":"Features","text":"<p>This library provides a AcsServiceServerRequestHandler ready to be use with the core LtiServiceServer to handle assessment control requests.</p> <ul> <li>it accepts a PSR7 ServerRequestInterface,</li> <li>leverages the required IMS LTI 1.3 service authentication,</li> <li>and returns a PSR7 ResponseInterface containing the <code>membership</code> representation</li> </ul>"},{"location":"libraries/lib-lti1p3-proctoring/doc/service/platform/#usage","title":"Usage","text":"<p>First, you need to provide a AcsServiceServerControlProcessorInterface implementation, in charge to process the ACS control requests.</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationInterface;\nuse OAT\\Library\\Lti1p3Proctoring\\Model\\AcsControlInterface;\nuse OAT\\Library\\Lti1p3Proctoring\\Model\\AcsControlResultInterface;\nuse OAT\\Library\\Lti1p3Proctoring\\Service\\Server\\Processor\\AcsServiceServerControlProcessorInterface;\n\n/** @var AcsServiceServerControlProcessorInterface $processor */\n$processor = new class() implements AcsServiceServerControlProcessorInterface \n{\n    public function process(\n        RegistrationInterface $registration,\n        AcsControlInterface $control\n    ) : AcsControlResultInterface {\n        // TODO: Implement process() method.\n    }\n};\n</code></pre> <p>Then:</p> <ul> <li>you can construct the AcsServiceServerRequestHandler (constructed with your AcsServiceServerControlProcessorInterface implementation)</li> <li>to finally expose it to requests using the core LtiServiceServer (constructed with the RequestAccessTokenValidator, from core library)</li> </ul> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\OAuth2\\Validator\\RequestAccessTokenValidator;\nuse OAT\\Library\\Lti1p3Core\\Service\\Server\\LtiServiceServer;\nuse OAT\\Library\\Lti1p3Proctoring\\Service\\Server\\Processor\\AcsServiceServerControlProcessorInterface;\nuse OAT\\Library\\Lti1p3Proctoring\\Service\\Server\\Handler\\AcsServiceServerRequestHandler;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n/** @var RegistrationRepositoryInterface $repository */\n$repository = ...\n\n/** @var AcsServiceServerControlProcessorInterface $processor */\n$processor = ...\n\n$validator = new RequestAccessTokenValidator($repository);\n\n$handler = new AcsServiceServerRequestHandler($processor);\n\n$server = new LtiServiceServer($validator, $handler);\n\n// Generates an authenticated response containing the control result representation\n$response = $server-&gt;handle($request);\n</code></pre>"},{"location":"libraries/lib-lti1p3-proctoring/doc/service/tool/","title":"ACS Tool - Assessment Control Service client","text":"<p>How to use the AcsServiceClient to perform authenticated ACS service calls as a tool.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/service/tool/#features","title":"Features","text":"<p>This library provides a AcsServiceClient (based on the core LtiServiceClient) that allow sending ACS controls to a platform.</p>"},{"location":"libraries/lib-lti1p3-proctoring/doc/service/tool/#usage","title":"Usage","text":""},{"location":"libraries/lib-lti1p3-proctoring/doc/service/tool/#send-an-acs-control","title":"Send an ACS control","text":"<pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Payload\\LtiMessagePayloadInterface;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Proctoring\\Model\\AcsControl;\nuse OAT\\Library\\Lti1p3Proctoring\\Model\\AcsControlResultInterface;\nuse OAT\\Library\\Lti1p3Proctoring\\Service\\Client\\AcsServiceClient;\n\n// Related registration\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Related LTI 1.3 message payload\n/** @var LtiMessagePayloadInterface $payload */\n$payload  = ...;\n\n$acsClient = new AcsServiceClient();\n\n$control = new AcsControl(...);\n\n/** @var AcsControlResultInterface $controlResult */\n$controlResult = $acsClient-&gt;sendControlForPayload(\n    $registration,  // [required] as the tool, it will call the platform of this registration\n    $control,       // [required] with provided ACS control\n    $payload        // [required] from the LTI message payload containing the ACS claim (got at LTI launch)\n\n);\n\n// you also can send a control for an ACS claim\n$controlResult = $acsClient-&gt;sendControlForClaim(\n    $registration,         // [required] as the tool, it will call the platform of this registration\n    $control,              // [required] with provided ACS control\n    $payload-&gt;getAcs()     // [required] from the ACS claim (got at LTI launch)\n\n);\n\n// or you also can send a control to an given URL\n/** @var AcsControlResultInterface $controlResult */\n$controlResult = $acsClient-&gt;sendControl(\n    $registration,              // [required] as the tool, it will call the platform of this registration\n    $control,                   // [required] with provided ACS control\n    'https://platform.com/acs'  // [required] to a given ACS service url\n);\n\n// Control result status\necho $controlResult-&gt;getStatus();\n\n// Control result extra time (if given)\necho $controlResult-&gt;getExtraTime();\n</code></pre>"},{"location":"libraries/lib-lti1p3-submission-review/","title":"TAO - LTI 1.3 Submission Review Library","text":"<p>PHP library for LTI 1.3 Submission Review Service implementations as platforms and / or as tools, based on LTI 1.3 Core library.</p>"},{"location":"libraries/lib-lti1p3-submission-review/#table-of-contents","title":"Table of contents","text":"<ul> <li>TAO LTI 1.3 PHP framework</li> <li>IMS</li> <li>Installation</li> <li>Documentation</li> <li>Tests</li> </ul>"},{"location":"libraries/lib-lti1p3-submission-review/#tao-lti-13-php-framework","title":"TAO LTI 1.3 PHP framework","text":"<p>This library is part of the TAO LTI 1.3 PHP framework.</p>"},{"location":"libraries/lib-lti1p3-submission-review/#ims","title":"IMS","text":"<p>You can find below IMS related information.</p>"},{"location":"libraries/lib-lti1p3-submission-review/#related-specifications","title":"Related specifications","text":"<ul> <li>IMS LTI Submission Review Service</li> <li>IMS LTI 1.3 Core</li> <li>IMS Security</li> </ul>"},{"location":"libraries/lib-lti1p3-submission-review/#installation","title":"Installation","text":"<pre><code>$ composer require oat-sa/lib-lti1p3-submission-review\n</code></pre>"},{"location":"libraries/lib-lti1p3-submission-review/#documentation","title":"Documentation","text":"<p>You can find below the library documentation, presented by topics.</p>"},{"location":"libraries/lib-lti1p3-submission-review/#quick-start","title":"Quick start","text":"<ul> <li>how to configure the underlying LTI 1.3 Core library</li> </ul>"},{"location":"libraries/lib-lti1p3-submission-review/#messages","title":"Messages","text":"<ul> <li>how to implement the submission review message workflow (as platform and / or tool)</li> </ul>"},{"location":"libraries/lib-lti1p3-submission-review/#tests","title":"Tests","text":"<p>To run tests:</p> <p><pre><code>$ vendor/bin/phpunit\n</code></pre> Note: see phpunit.xml.dist for available test suites.</p>"},{"location":"libraries/lib-lti1p3-submission-review/doc/message/submission-review-workflow/","title":"Submission Review Message Workflow","text":"<p>How to perform secured submission review message interactions, between platforms and tools.</p>"},{"location":"libraries/lib-lti1p3-submission-review/doc/message/submission-review-workflow/#workflow","title":"Workflow","text":"<p>You can find below a submission review message workflow diagram, with steps numbers:</p> <p></p> <p>Each step will be detailed below, from both platform and tool perspectives.</p>"},{"location":"libraries/lib-lti1p3-submission-review/doc/message/submission-review-workflow/#1-platform-side-ltisubmissionreviewrequest-message-generation","title":"1 - Platform side: LtiSubmissionReviewRequest message generation","text":"<p>You can find below required steps to generate a LtiSubmissionReviewRequest message, needed only if you're acting as a platform.</p>"},{"location":"libraries/lib-lti1p3-submission-review/doc/message/submission-review-workflow/#create-the-message","title":"Create the message","text":"<p>As a platform, you can create a LtiSubmissionReviewRequest message for a tool within the context of a registration.</p> <p>Platforms can drive the tool behaviour on submission review interactions by providing claims in this message.</p> <p>You can use the SubmissionReviewLaunchRequestBuilder to create the message:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Payload\\Claim\\AgsClaim;\nuse OAT\\Library\\Lti1p3Core\\Message\\Payload\\Claim\\ForUserClaim;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3SubmissionReview\\Message\\Launch\\Builder\\SubmissionReviewLaunchRequestBuilder;\n\n// Create mandatory submission review claims\n$agsClaim = new AgsClaim(...);\n$forUserClaim = new ForUserClaim(...);\n\n// Create a builder instance\n$builder = new SubmissionReviewLaunchRequestBuilder();\n\n// Get related registration of the launch\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Build LtiSubmissionReviewRequest message\n$message = $builder-&gt;buildSubmissionReviewLaunchRequest(\n    $agsClaim,                                                     // [required] AGS claim\n    $forUserClaim,                                                 // [required] for_user claim\n    $registration,                                                 // [required] related registration\n    'loginHint',                                                   // [required] login hint that will be used afterwards by the platform to perform authentication\n    'http://tool.com/submission-review',                           // [optional] tool url where to send the LtiSubmissionReviewRequest message (if none provided will use default tool launch url)\n    null,                                                          // [optional] will use the registration default deployment id, but you can pass a specific one\n    ['http://purl.imsglobal.org/vocab/lis/v2/membership#Learner'], // [optional] roles\n    ['myCustomClaim' =&gt; 'myCustomValue']                           // [optional] supplementary claims if needed\n);\n</code></pre> <p>Since AGS line items can be coupled to LTI resource links, you can also use the <code>buildLtiResourceLinkSubmissionReviewLaunchRequest()</code> method to ease the message creation: </p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Payload\\Claim\\AgsClaim;\nuse OAT\\Library\\Lti1p3Core\\Message\\Payload\\Claim\\ForUserClaim;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Resource\\LtiResourceLink\\LtiResourceLink;\nuse OAT\\Library\\Lti1p3SubmissionReview\\Message\\Launch\\Builder\\SubmissionReviewLaunchRequestBuilder;\n\n// Create a resource link\n$resourceLink = new LtiResourceLink('resourceLinkIdentifier');\n\n// Create mandatory submission review claims\n$agsClaim = new AgsClaim(...);\n$forUserClaim = new ForUserClaim(...);\n\n// Create a builder instance\n$builder = new SubmissionReviewLaunchRequestBuilder();\n\n// Get related registration of the launch\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registration = $registrationRepository-&gt;find(...);\n\n// Build LtiSubmissionReviewRequest message\n$message = $builder-&gt;buildLtiResourceLinkSubmissionReviewLaunchRequest(\n    $resourceLink,                                                 // [required] resource link\n    $agsClaim,                                                     // [required] AGS claim\n    $forUserClaim,                                                 // [required] for_user claim\n    $registration,                                                 // [required] related registration\n    'loginHint',                                                   // [required] login hint that will be used afterwards by the platform to perform authentication\n    'http://tool.com/submission-review',                           // [optional] tool url where to send the LtiSubmissionReviewRequest message (if none provided will use default tool launch url)\n    null,                                                          // [optional] will use the registration default deployment id, but you can pass a specific one\n    ['http://purl.imsglobal.org/vocab/lis/v2/membership#Learner'], // [optional] roles\n    ['myCustomClaim' =&gt; 'myCustomValue']                           // [optional] supplementary claims if needed\n);\n</code></pre>"},{"location":"libraries/lib-lti1p3-submission-review/doc/message/submission-review-workflow/#launch-the-message","title":"Launch the message","text":"<p>As a result of the build, you get a LtiMessageInterface instance that has to be used in the following ways:</p> <pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\LtiMessageInterface;\n\n/** @var LtiMessageInterface $message */\n\n// Main message properties you can use as you want to offer the launch to the platform users\necho $message-&gt;getUrl();                // url of the launch\necho $message-&gt;getParameters()-&gt;all();  // array of parameters of the launch\n\n// Or use those helpers methods to ease the launch interactions\necho $message-&gt;toUrl();                // url with launch parameters as query parameters\necho $message-&gt;toHtmlLink('click me'); // HTML link, where href is the output url\necho $message-&gt;toHtmlRedirectForm();   // HTML hidden form, with possibility of auto redirection\n</code></pre>"},{"location":"libraries/lib-lti1p3-submission-review/doc/message/submission-review-workflow/#implement-openid-connect-launch-flow","title":"Implement OpenId Connect launch flow","text":"<p>Like any platform originating message, when the LtiSubmissionReviewRequest message is launched, an OIDC flow will start between the tool and the platform.</p> <p>The underlying core library offers everything you need to securely implement this flow, as documented in the platform originating messages documentation.</p>"},{"location":"libraries/lib-lti1p3-submission-review/doc/message/submission-review-workflow/#2-tool-side-ltisubmissionreviewrequest-message-handling","title":"2 - Tool side: LtiSubmissionReviewRequest message handling","text":"<p>You can find below required steps to handle a LtiSubmissionReviewRequest message, needed only if you're acting as a tool.</p>"},{"location":"libraries/lib-lti1p3-submission-review/doc/message/submission-review-workflow/#validate-the-message","title":"Validate the message","text":"<p>As a tool, you'll receive an HTTP request containing the LtiSubmissionReviewRequest message, generated by the platform, received after OIDC flow completion.</p> <p>You can use the ToolLaunchValidator to validate it:</p> <p><pre><code>&lt;?php\n\nuse OAT\\Library\\Lti1p3Core\\Message\\Launch\\Validator\\Tool\\ToolLaunchValidator;\nuse OAT\\Library\\Lti1p3Core\\Registration\\RegistrationRepositoryInterface;\nuse OAT\\Library\\Lti1p3Core\\Security\\Nonce\\NonceRepositoryInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n/** @var RegistrationRepositoryInterface $registrationRepository */\n$registrationRepository = ...\n\n/** @var NonceRepositoryInterface $nonceRepository */\n$nonceRepository = ...\n\n/** @var ServerRequestInterface $request */\n$request = ...\n\n// Create the validator\n$validator = new ToolLaunchValidator($registrationRepository, $nonceRepository);\n\n// Perform validation\n$result = $validator-&gt;validatePlatformOriginatingLaunch($request);\n\nif (!$result-&gt;hasError()) {\n    // You can access the related AGS line item\n    $lineItemUrl = $result-&gt;getPayload()-&gt;getAgs()-&gt;getLineItemUrl();\n\n    // You can access the user details for whom is done the submission review\n    $user = $result-&gt;getPayload()-&gt;getForUser();\n\n    // Then implement your logic to handle the LtiSubmissionReviewRequest message and offer submission review\n}\n</code></pre> Note: more details about platform originating messages on tool side validation can be found in the platform originating messages documentation.</p>"}]}